{
    "componentChunkName": "component---src-templates-course-content-template-js",
    "path": "/luku-2/3-konekaskyt",
    "result": {"data":{"page":{"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"lead","properties":{},"children":[{"type":"text","value":"Tässä osiossa tutustumme tarkemmin konekäskyihin. Selvitämme mm., mitä ominaisuuksia konekäskyissä on ja minkälaisia konekäskyjä suorittimissa voi olla. Esittelemme samalla myös (osan) esimerkkitietokoneen ttk-91 käskyistä ja annamme esimerkkejä (symbolisesta) konekielisestä koodista."}]},{"type":"text","value":"\n"}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Konekäskykanta"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Suorittimen kaikki konekäskyt yhdessä muodostavat sen konekäskykannan, joka on käyttöliittymä suorittimella tapahtuvaan laskentaan. Laskenta tapahtuu suorittimen rekistereiden välillä ja konekäskyissä yleensä nimetään kaikki sen käyttämät rekisterit."}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Rekistereiden lukumäärä konekäskyssä"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Yksi tapa luokitella konekäskykantoja perustuu siihen, kuinka monta operandia konekäskyjen aritmetiikkaoperaatioissa voi nimetä. Joissakin tapauksissa riittää yhden operandin nimeäminen. Tällöin toinen operandi ja tulos ovat aina yksi ja sama oletusarvoinen \"akkurekisteri\". Sen arvo tulee väkisten tuhottua operaation aikana, koska uusi tulos kirjoitetaan samalle paikalle akkurekisteriin."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Useissa konekielissä käskyssä voi aritmetiikkaoperaatioissa nimetä kaksi operandia. Toinen niistä on samalla tulosrekisteri. Tässäkin tapauksessa on se huono piirre, että toinen operandi tuhoutuu käskyn suorituksen aikana. Hyvänä ominaisuutena on kuitenkin se, että näissä prosessoreissa on useampi rekisteri, joten ongelma ei ole niin suuri."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Nykyisissä konekielissä on yleistä, että operandeja on aritmetiikkaoperaatioissa nimetty kolme kappaletta ja ne ovat kaikki rekistereitä. Näin kummankaan operandin arvoa ei tarvitse tuhota, ellei sitä erityisesti haluta nimeämällä tulosrekisteri samaksi kuin toinen operandirekistereistä. Nämä suoritinarkkitehtuurit ovat yleensä ns. "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"load-store arkkitehtuureja"}]},{"type":"text","value":", joissa muistiviittauksia tekevät käskyt eivät tee samalla aritmeettis-loogisia operaatioita."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"On myös määritelty konekäskykantoja, joissa aritmetiikkaoperaatioissa ei ole nimetty lainkaan rekistereitä. Tuollaiset koneet ovat ns. "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"pinokoneita"}]},{"type":"text","value":", joissa laskenta tapahtuu "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"pinoa"}]},{"type":"text","value":" käyttäen. Pinon voi mieltää pöydällä olevaksi korttipakaksi. Operandit löytyvät pinon pinnalta ja tulos talletetaan myös pinoon. Esimerkiksi yhteenlaskun yhteydessä pinosta poistetaan (päältä) kaksi arvoa operandeiksi, arvot lasketaan yhteen ja tulos talletetaan pinoon päällimmäiseksi. Pino on talletettu muistiin ja sen pinnalle osoittaa sisäinen pinorekisteri (SP, Stack Pointer). Korttipakkaesimerkkiä käyttäen yhteenlaskussa otamme pinon pinnalta kaksi korttia (ruutu 5 ja hertta 3) ja laitamme takaisin niiden arvojen summan (pata 8). Esimerkki ei toimi, jos pinon pinnalla on vain kuvakortteja, koska pelikorttien arvoalue on niin pieni."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Esimerkkikoneessa ttk-91 voi yhdessä konekäskyssä nimetä kaksi operandia, joista ensimmäinen on aina rekisteri. Toinen operandi voi olla joku rekisteri, se voi olla vakio, tai se voidaan määritellä näiden yhdistelmänä. Se voi olla myös muistissa, kuten seuraavassa on tehty."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Load-store arkkitehtuurin koodissa on paljon konekäskyjä, mutta sen suoritus voi olla hyvin nopeaa. Laskenta on erikseen muistioperaatioista ja suorittimella on riittävästi rekistereitä koodin suoritusnopeuden optimoimiseksi. Fiksu suoritin voisi osata noutaa A:n ja B:n arvot osittain samanaikaisesti muistista, koska käskyt ovat täysin riippumattomia toisistaan."}]},{"type":"comment","value":" esimerkki Yhteenlasku eri tyyppisillä suorittimilla "},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Yhteenlasku eri tyyppisillä suorittimilla\n\nLaske C=A+B, kun A, B ja C ovat muuttujia muistissa eri\ntyyppisillä suorittimilla. Operandien lukumäärä\nADD-käskyssä on 0, 1, 2 tai 3.\n\nPinokone   Akkurek.    Ttk-91        Load-store\n(0 oper.)  (1 oper.)   (2 oper.)     (3 oper.)\n\npush A     load  A     load  r4,A    load  r10,A\npush B     add   B     add   r4,B    load  r11,B\nadd        store C     store r4,C    add   r12,r10,r11\npop C                                store r12,C"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Olisi mukava, jos nopeita rekistereitä olisi paljon, koska tiedot löytyisivät tällöin usein mahdollisimman nopeasti. Suuri määrä rekistereitä kuitenkin tarkoittaa, että tarvitsemme enemmän bittejä niiden osoittamiseen konekäskyissä. Jos rekistereitä on 16, niin neljä bittiä riittää rekisterin osoitteeksi. Toisaalta, 128 rekisterille tarvitaan jo 7 bittiä niiden osoittamiseen. Tuolloin kolmen rekisterin nimeämiseen kuluu jo 21 bittiä, mikä tekee konekäskyistä ehkä turhan pitkiä. Usein rekistereitä on 16-32 kappaletta kutakin eri tyyppiä, jolloin yhden rekisterin nimeämiseen riittää 4-5 bittiä konekäskyissä."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Esimerkkikoneessa ttk-91 on 8 rekisteriä, joten niiden nimeämiseen konekäskyssä tarvitaan 3 bittiä. Konekäskyssä voi viitata kahteen rekisteriin. Jälkimmäistä rekisteriä sanotaan "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"indeksirekisteriksi"}]},{"type":"text","value":", koska sitä voidaan käyttää indeksinä taulukkoviitauksissa."}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Eri tavat viitata muistiin"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Konekäskyssä tarvitaan jonkinlaisia tapoja viitata muistiin. Korkean tason kielissä usein käytetyt tietotyypit voivat vaatia erilaisia viittaustapoja. Yleisiä tietotyyppejä korkean tason kielissä ovat muuttujat, vakiot ja 1-, 2- tai 3-ulotteiset taulukot. Sellaisia ovat myös "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"tietueet"}]},{"type":"text","value":" tai "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"oliot"}]},{"type":"text","value":", joissa on erilaisia kenttiä. Usein tieto on myös esitetty epäsuorasti, jolloin tietorakenteessa ei olekaan itse tietoa, vaan ainoastaan osoite tietoon."}]},{"type":"comment","value":" Note: tietue ja olio "},{"type":"element","tagName":"text-box","properties":{"variant":"example","name":"Tietueet ja oliot"},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tietue on esimerkki rakenteisesta tiedosta. Esimerkiksi harrasteseuran jäsenrekisteri voisi koostua tietueista, joista kukin kertoo yhden jäsenen tiedot. Kullakin tietueella on sama rakenne ja se sisältää samat (tieto)kentät. Tällaisia kenttiä olisivat esimerkiksi jäsenen nimi, osoite ja puhelinnumero.\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\nOlio on kehittyneempi muoto tietueesta. Siellä on tiedon lisäksi myös kokoelma metodeja (aliohjelmia, funktioita), joiden avulla olion tietoja voidaan lukea ja muokata. Tyypillisesti olion tietoja voi lukea tai kirjottaa vain sen omien metodien kautta. Tämä tekee helpommaksi ja luotettavammaksi olion tietojen käytön, kun kaikki samaa tietoa käsittelevä koodi on keskitetty yhteen paikkaan. Koodausvirheiden havaitseminen on helpompaa verrattuna tilanteeseen, jossa samaa tietoa käsiteltäisiin siellä täällä esimerkiksi 40000 koodirivin ohjelmistossa. Jos harrasteseuran jäsenrekisteri toteutettaisiin oliona (esim. JäsR), niin jäsenten tiedot olisivat olion sisäisiä tietorakenteita ja niitä pääsisi käyttämään ainoastaan olion metodeja kutsumalla. Tällaisia metodeja olisivat esimerkiksi JäsR.UusiJäsen(), JäsR.LueOsoite() ja JäsR.MuutaOsoite() avulla."}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Olisi mukavaa, jos tietoon useimmiten pystyisi viittaamaan yksinkertaisesti yhden käskyn sisältä jotain suorittimella toteutettua muistinviittaustapaa käyttäen. Aina tämä ei ole mahdollista. Tällöin viitattu muistiosoite lasketaan ensin johonkin rekisteriin suorittamalla usea konekäsky ja sitten vihdoin itse muistiviite voidaan toteuttaa yhdellä konekäskyllä tuon rekisterin kautta. Tyypillisesti näin tehdään vaikkapa viitatessa 3-ulotteisen taulukon alkioihin, koska juuri missään suorittimessa ei ole valmista muistinviittaustapaa 3-ulotteisille taulukoille."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Viitattu tieto voi sijaita tietyssä muistiosoitteessa, joten konekäskyssä olisi mukava olla suoraan paikka tuolle osoitteelle. Joissakin korkean tason kielissä (esim. C) on "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"pointtereita"}]},{"type":"text","value":" eli "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"osoitinmuuttujia"}]},{"type":"text","value":", jotka eivät sisällä itse tietoa vaan ainoastaan tiedon osoitteen muistissa. Tietoon viitatessa pitää ensin hakea muistista pointterin arvo ja vasta sitten sen avulla hakea muistista laskennassa tarvittava data. Kyseessä on tällöin "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"epäsuora muistiviite"}]},{"type":"text","value":". Useissa korkean tason ohjelmointikielissä (esim. Java) taas ei tietoisesti ole pointtereita, koska niiden käyttö on vaativaa ja johtaa helposti ohjelmointivirheisiin."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Usein osoite voi olla suhteellinen jonkin rekisterin suhteen. Viitatun tiedon osoite saadaan nyt laskemalla yhteen tuon rekisterin ja jonkin vakion arvot yhteen. Tällaista kutsutaan "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"indeksoiduksi tiedonosoitukseksi"}]},{"type":"text","value":". Esimerkiksi 1-ulotteisten taulukoiden tapauksessa tuo vakio voi olla taulukon alkuosoite muistissa ja rekisterin arvo kyseisen taulukon "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"indeksi"}]},{"type":"text","value":". Toisaalta taas tietueen tai olion tapauksessa rekisterissä on yleensä tietueen tai olion muistiosoite, ja vakiona on viitatun kentän suhteellinen osoite tietueessa tai oliossa. On hyvin käytännöllistä, että samalla tiedonosoitustavalla voidaan ratkaista kahden hyvin yleisen mutta silti erilaisen tietorakenteen käyttö. Lähes kaikissa suorittimissa on indeksoitu tiedonosoitus käytettävissä."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Muistiosoitteen laskennassa voidaan myös käyttää useampaa rekisteriä ja näin viitata esimerkiksi 2-ulotteisen taulukon alkioon hyvin helposti. Tällainen tiedonosoitustapa on kuitenkin nykyään harvinainen, koska se on niin monimutkainen muihin tapoihin verrattuna. Yksinkertaisien konekäskyjen suoritusnopeus on helpompi optimoida kuin monimutkaisten tiedonosoitustapojen."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Esimerkkikoneessa ttk-91 on kolme tiedonosoitustapaa ja ne perustuvat kaikki indeksoituun tiedonosoitukseen. Ensin lasketaan ohjelman käyttämä \"muistiosoite\" laskemalla yhteen käskyssä oleva vakio ja käskyssä olevan "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"indeksirekisterin"}]},{"type":"text","value":" arvo. Jos \"osoite\" löytyy suoraan indeksirekisteristä, niin vakioksi laitetaan nolla. Jos \"osoitteeksi\" haluttiin pelkästään käskyssä oleva vakio, niin tämä on koodattu käskyyn laittamalla indeksirekisteriksi R0. Indeksirekisteriä R0 ei tämän vuoksi voi käyttää indeksointiin."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ttk-91:n suorittimella on kolme vaihtoehtoista tapaa saada jälkimmäinen operandi edellä lasketun \"muistiosoitteen\" avulla ja ne valitaan 2-bittisen "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"tiedonosoitusmoodin"}]},{"type":"text","value":" avulla. Moodin arvo 0 ("},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"välitön tiedonosoitus"}]},{"type":"text","value":") tarkoittaa, että tuo äsken laskettu \"muistiosoite\" on sellaisenaan toinen operandi, eikä mitään muistiviitettä tarvita. Moodin arvo 1 ("},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"suora muistiviite"}]},{"type":"text","value":") tarkoittaa, että muistiosoitetta käytetään yhden kerran operandin hakemiseksi muistista. Moodin arvo 2 ("},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"epäsuora muistiviite"}]},{"type":"text","value":") tarkoittaa, että ensin haetaan muistista edellä laskettua muistiosoitetta käyttäen toisen operandin osoite ja vasta sitten haetaan muistista tuota osoitetta käyttämällä jälkimmäinen operandi."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Esimerkki: Ttk-91 käskyn toisen operandin arvon nouto TR:ään. Oletetaan, että käskyrekisterissä IR on jokin ttk-91 konekäsky. Suoritin toteuttaa seuraavat vaiheet kontrolliyksikön käskyttämänä:\n\n\n\nKopioi käskyn vakiokentän arvo tilapäisrekisteriin TR.\n\nJos käskyn oikeanpuoleisen rekisterin numero eri kuin 0:\n    Laske operandin tosiasiallinen osoite (tai arvo) seuraavasti:\n        Kopioi käskyn oikeanpuoleisen rekisterin arvo ALU:n operandiksi 1,\n        Kopioi rekisterin TR arvo ALU:n operandiksi 2,\n        Anna ALU:lle kontrollijohtimia pitkin komento \"add\",\n        Odota vähän aikaa,\n        Kopioi ALU:n ulostulo rekisteriin TR.\n        (Nyt operandin tosiasiallinen osoite (tai arvo) on TR:ssä.)\n\nJos käskyn moodi-kentän arvo on vähintään 1,\n    Kopioi TR:n arvo rekisteriin MAR,\n    Anna väylän kontrollirekisterille (Bus Ctl) komento \"Read\",\n    Odota vähän aikaa, että arvo saapuu muistista väylää pitkin MBR:ään.\n    Kopio rekisterin MBR arvo rekisteriin TR.\n\nJos käskyn moodi-kentän arvo on vähintään 2,\n    Kopioi TR:n arvo rekisteriin MAR,\n    Anna väylän kontrollirekisterille (Bus Ctl) komento \"Read\",\n    Odota vähän aikaa, että arvo saapuu muistista väylää pitkin MBR:ään.\n    Kopio rekisterin MBR arvo rekisteriin TR.\n\nJos käskyn moodi-kentän arvo on vähintään 3,\n    Aiheuta virhetilanne (\"Bad Mode\") ja keskeytä käskyn suoritus."}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ttk-91 koneen symbolisessa konekielessä "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"välitön tiedonosoitus"}]},{"type":"text","value":" kuvataan ennen vakio-osaa olevalla '='-merkillä. "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Epäsuora muistiviite"}]},{"type":"text","value":" kuvataan vastaavasti ennen vakio-osaa olevalla '@'-merkillä, kun "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"suorassa muistiviitteessä"}]},{"type":"text","value":" vakio-osa on sellaisenaan ilman mitään erikoismerkkejä."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Esimerkki: Ttk-91 symbolisen konekielen tiedonosoitusmoodi\n\nOletetaan, että kaikissa käskyissä alkuaan rekisterin r1 arvo\non 3, rekisterin r2 arvo on 10, muistipaikan mem(17) arvo on 45,\nja että muistipaikan mem(45) arvo on 88.\n\n               op.koodi rek-1   moodi ind.rek. vakio  tulos\nload r1, r2      -- 2      1        0     2        0    r1 <- 10\nload r1, =7      -- 2      1        0     0        7    r1 <- 7\nload r1, =7(r2)  -- 2      1        0     2        7    r1 <- 17\nload r1, 7(r2)   -- 2      1        1     2        7    r1 <- 45\nload r1, @7(r2)  -- 2      1        2     2        7    r1 <- 88\nstore r1, 7(r2)  -- 1      1        0     2        7  mem(17) <- 3\nstore r1, @7(r2) -- 1      1        1     2        7  mem(45) <- 3"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Käskyn moodi-kentän arvon kertoo siis muistista "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"lukujen"}]},{"type":"text","value":" lukumäärän käskyn suoritusaikana. Muistiin kirjoituskäskyn (STORE) yhteydessä moodikentän arvo on yhtä pienempi kuin vastaavassa muistin lukukäskyssä (LOAD) ja sillä tarkoitetaan aina suoraa tai epäsuoraa muistiviitettä. Käskyn suoritusaikana STORE-käskyssä tulee lopuksi aina yksi muistiin "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"kirjoitus"}]},{"type":"text","value":"."}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Konekäskyjen pituus ja muoto"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Vaihtelevasta konekäskyjen pituudesta on se hyöty, että eri käskyillä voi olla erilaisia kenttiä. Esimerkiksi pelkästään rekistereiden välillä operoiva konekäsky ei tarvitse vakio-kenttää, mutta muistinviittauksen yhteydessä vakiokentästä taas olisi hyötyä. Joissakin tapauksissa vakiokenttä voisi olla kovinkin lyhyt (esim. 8 bittiä), kun taas muistisoitteiden tapauksissa se voisi olla jopa 32-bittinen tai pidempikin. Vaihtelevasta konekäskyjen pituudesta on kuitenkin myös haittaa. Käskyjen nouto muistista on vaikeata, kun ei heti tiedetä mitenkä monta tavua tarvitsee noutaa. Tavujen määrä selviää vasta kun operaatiokoodi on ensin haettu muistista. Tämän vuoksi nykyään yleensä käytetään usein vain vakiomittaisia konekäskyjä."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Konekäskyjä voi olla useata eri muotoa. Absoluuttinen hyppykäsky ei tarvitse operaatiokoodin lisäksi kuin hyppyosoitteen. Muistiviittauskäskyt voivat käyttää erilaisia muistinviittausmuotoja, joista jotkut käyttävät rekistereitä apunaan ja jotkut eivät. Aritmeettis-loogisissa operaatioissa voidaan tarvita yksi, kaksi tai kolme nimettyä rekisteriä. Yleensä konekäskyn muoto määräytyy suoraan sen operaatiokoodin perusteella, mutta joissakin konekielissä jokaisen operandin muoto voi määräytyä erikseen."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Esimerkkikoneen ttk-91 kaikki konekäskyt ovat 32-bittisiä ja niillä on kaikilla sama muoto: operaatiokoodi 8 bittiä, operandi/tulosrekisteri 3 bittiä, tiedonosoitusmoodi 2 bittiä, indeksirekisteri 3 bittiä ja vakiokenttä 16 bittiä. Tiedonosoitusmoodin käyttö voi tuntua aluksi sekavalta, mutta käytännön ohjelmoinnissa eri tiedonosoitusmoodeja tarvitaan koko ajan. Tällä kurssilla emme perehdy varsinaiseen konekieliseen ohjelmointiin muutamaa triviaalia esimerkkiä enempää."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Esimerkki: Ttk-91 symbolisen konekielen käskyjen talletusmuoto\n\n     kentät:      op.koodi tul.rek. moodi ind.rek. vakiokenttä\n     bittejä:        8        3       2      3        16\n\n    -- Hae X:n arvo muistista rekisteriin r1.\n    -- Muuttujan X osoite on sama kuin symbolin X arvo.\nload r1, X         2 (load)     1      1     0     X:n osoite\n\n    -- Lisää r2:n arvoon luku 6\nadd  r2, =6        17 (add)     2      0     0     6\n\n    -- Kerro r4:n arvo muistissa olevan taulukon Tbl alkion i arvolla,\n    -- kun i on r1:n arvo.\n    -- Taulukon Tbl osoite on sama kuin symbolin Tbl arvo.\nmul  r4, Tbl(r1)   19 (mul)     4      1     1     Tbl:n osoite\n\n    -- Jaa r3:n arvo luvulla, jonka osoite on muistissa\n                              osoitinmuuttujan ptrX arvona.\n    -- Osoitinmuuttujan ptrX osoite on sama kuin symbolin ptrX arvo.\ndiv  r3, @ptrX     20 (div)     3      2     0     ptrX:n osoite\n\n    -- Hyppää osoitteeseen loop, jos r2:n arvo on <0.\n    -- Silmukan loop osoite on sama kuin symbolin loop arvo\njpos  r2, loop     35 (jpos)    2      0     0     loop'in osoite\n\n    -- Talleta r2:n arvo muistissa olevan muuttujan Y arvoksi.\n    -- Rekisterin r2 arvo säilyy ennallaan.\n    -- Muuttujan Y osoite on sama kuin symbolin Y arvo.\nstore r2, Y        1 (store)    2      0     0     Y:n osoite"}]}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Tiedon tyypit"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tietokone osaa (tietenkin) käsitellä kaiken tyyppistä tietoa. Suoritin ymmärtää kuitenkin vain muutamaa tietotyyppiä, joita varten on omat konekäskynsä. Kaikki muu tieto pitää kuvata näiden muutaman tietotyypin avulla. Sellaisen tiedon käsittely tapahtuu ohjelmallisesti, yleensä kutakin tietotyyppiä varten erikseen suunniteltujen aliohjelmien avulla."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Kokonaisluvut"}]},{"type":"text","value":" ovat yleensä kaikissa suorittimissa. Useissa on kokonaislukuja muutamaa eri pituutta, esimerkiksi 8-, 16-, 32  ja 64-bittisiä. On ehkä yllättävää, että kaikki tietokoneella ratkaistavissa olevat ongelmat voidaan ratkaista pelkästään kokonaislukujen avulla. Se ei ole kuitenkaan yksinkertaisin tai tehokkain tapa."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Missään suorittimessa ei ole reaalilukuja. Esimerkiksi, piin tarkka arvo vaatisi äärettömän suuren muistialueen. Sen sijaan suorittimissa käytetään "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"liukulukuja"}]},{"type":"text","value":", jotka ovat reaalilukujen kiinteän mittaisia likiarvoja. Liukulukuja on tyypillisesti kahta eri pituutta, 32- ja 64-bittisiä. Esimerkiksi, pii voitaisiin esittää tällöin likiarvona 3.1415927 tai 3.1415926535897931. Kaikissa suorittimissa ei ole edes liukulukuja, koska yksinkertaisissa laitteissa ei ole tarvetta sen tyyppiselle laskennalle."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Joissakin (vanhemmissa) suorittimissa on tietotyyppi "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"totuusarvo"}]},{"type":"text","value":" (tosi ja epätosi). Nykyään totuusarvoja käsitellään bitteinä, jolloin tosi on koodattu lukuna 1 ja epätosi lukuna 0. Bittejä käsitellään raakadatan bittioperaatioilla (ks. alla)."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Vanhemmissa suorittimissa saattoi olla myös tietotyypit "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"merkeille"}]},{"type":"text","value":" ja "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"merkkijonoille"}]},{"type":"text","value":". Huonona puolena tässä oli, että koko järjestelmän piti rajoittua johonkin tiettyyn merkkien ja merkkijonojen esitystapaan. Nykyään käytössä on useita eri merkistöjä. Niiden merkit on koodattu kokonaislukujen avulla ja niitä käsitellään kokonaislukuina."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Kaikki tieto esitetään suorittimella loppujen lopuksi bitteinä, ja suorittimissa on yleensä myös tällainen raakadatan bittiesitysmuoto. Niillä käsitellään tietoa bitteinä riippumatta siitä, mitä nuo bitit tarkoittavat. Joissakin tapauksissa esimerkiksi kokonaislukuja voi olla järkevää käsitellä pelkästään niiden esitysmuodossa bitteinä kuin kokonaislukuina."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Käsittelemme eri tyyppisten tietojen esitystapoja tarkemmin seuraavassa luvussa."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Esimerkkitietokoneessa ttk-91 on vain 32-bittisiä kokonaislukuja ja bittiesitysmuodon 32-bittisiä sanoja."}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Konekäskyt"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Käskykannassa on kullekin suorittimen ymmärtämälle tietotyypille sen ominaiset perusoperaatiot. Jos samasta tietotyypistä (esim. kokonaisluvut) on olemassa eri pituisia muotoja (esim. 8-, 16-, 32- ja 64-bittiset esitysmuodot), niin tiedon pituus tulee koodata jollain tavoin. Pituus voi olla koodattu omalla operaatiokoodilla tai lisämääreellä. Lisäksi suorittimella on sekalainen joukko konekäskyjä suorittimen yleishallintoon ja käyttöjärjestelmän toimintojen tukemiseen."}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Aritmetiikkakäskyt"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Aritmetiikkakäskyissä on mukana aina yhteenlasku, vähennyslasku ja kertolasku. Usein siellä on myös jakolasku, mutta ei aina. Joskus jakolasku toteutetaan kertomalla jaettava jakajan käänteisluvulla, koska se voi olla nopeampaa. Kokonaislukujen jakolaskusta voi tulla talteen myös jakojäännös, mutta usein se pitää kaivaa esiin omalla modulo-konekäskyllä (esim., MOD-käsky)."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Liukuluvuille on omat vastaavat konekäskynsä. Niiden toteutus on jonkin verran monimutkaisempaa kuin kokonaislukujen käsittely ja ne käyttävät yleensä niille varattuja omia liukulukurekistereitä."}]},{"type":"comment","value":" Koodiesimerkki (ei ttk-91) "},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Esimerkki: yhteenlasku eri tyyppisillä tiedoilla (ei ttk-91)\n\nLaske C=A+B, kun A, B ja C ovat muuttujia muistissa\nsamalla suorittimella. Kustakin muuttujasta on kolme\nversiota. Muuttuja iA on kokonaisluku, fA on\n32-bittinen liukuluku, dA on 64-bittinen liukuluku, jne.\n\nkokon.luvuilla  liukuluvuilla  64-bitt. liukuluvuilla\n\nload  r1,iA      load f1,fA       dload f2,dA\nload  r2,iB      load f2,fB       dload f4,dB\nadd   r3,r1,r2   fadd f3,f1,f2    dfadd f6,f2,f4\nstore r3,iC      store f3,fC      dstore f6,dC"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"64-bittiset rekisterit muodostetaan usein yhdistämällä kaksi peräkkäistä 32-bittistä rekisteriä. Esimerkin 64-bittiset liukuluvut on talletettu kahteen peräkkäiseen 32-bittiseen liukulukurekisteriin. Muuttujan dA 64-bittinen arvo ladataan rekisteriin f2-f3, jne."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ttk-91:ssä on vain kokonaislukujen konekäskyt ADD, SUB, MUL, DIV ja MOD. Siinä ei ole käskyjä liukulukujen käsittelyyn ja sen käskyssä voi nimetä vain kaksi rekisteriä."}]},{"type":"comment","value":" Note: matem historia, kertolasku, Fibonacci, helmitaulun algoritmi "},{"type":"element","tagName":"text-box","properties":{"variant":"example","name":"Kertolaskun historiaa"},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Kertolasku on monimutkaisin operaatio, minkä suoritin pystyy tekemään. Sen monimutkaisuutta ei kannata väheksyä, vaikka olet itse oppinut sen tekemään jo koulussa. Kokonaislukujen kertolasku oli vielä 800 vuotta sitten niin haastavaa, että sen tekemiseen palkattiin ulkopuolinen konsultti. Hänellä oli käytössään useimmiten helmitaulu (abacus) ja siihen sopiva algoritmi. Ongelmana oli, että lukujen esityksessä käytetty menetelmä (esim. roomalaiset numerot) sopi hyvin lukujen tallentamiseen, mutta ei niillä laskemiseen. Konsultti muutti luvut ensin helmitaululle sopivaan muotoon, ratkaisi ongelman ja antoi lopulta asiakkaalle tuloksen hänen ymmärtämässään muodossa.\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\nTilanne muuttui radikaalisti 10-järjestelmän keksimisen jälkeen. Fibonacci toi sen vuonna 1202 Eurooppaan kirjassaan Liber abaci. Uusi merkintätapa oli helposti opittavissa ja nyt kuka tahansa saattoi oppia aika yksinkertaiset algoritmit peruslaskutoimituksien tekemiseen noita samoja numeroita käyttäen. Kerta kaikkiaan nerokasta!\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\nTilanne on nyt vähän samanlainen kuin 800 vuotta sitten, mutta helmitaulun asemesta käytetään tietokonetta. Asiakkaat antavat konsulttiyritykselle ratkaistavan tehtävän tekstinä. Ohjelmoijat suunnittelevat ongelman ratkaisun tietokoneohjelmaksi. Tietokone suorittaa binäärimuotoisen algoritmin asiakkaan antamia lähtötietoja käyttäen. Lopulta ratkaisu annetaan asiakkaalle tekstinä ja 10-järjestelmän lukuina. Ohjelmoijien ratkaisevat ongelmat ovat nykyään tietenkin aika lailla monimutkaisempia kuin kertolasku. Asiakkaan ei kuitenkaan edelleenkään tarvitse ymmärtää, kuinka ohjelmoija tai tietokone ongelman oikeastaan ratkaisee."}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Bittioperaatiot"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Bittien käsittelyä varten mukana on yleensä ainakin loogiset operaatiot AND, OR, XOR ja NOT. NOT-käskyllä on vain yksi operandi ja se komplementoi jokaisen bitin. Muilla käskyillä on kaksi operandia ja ne tekevät valitun loogisen-operaation pareittain jokaiselle operandien bitille. AND-operaation tulos on 1 (tosi), jos molemmat vastaavat bitit ovat 1, ja muutoin tulos on 0. OR-operaation tulos on 1, jos jompi kumpi tai molemmat operandibiteistä on 1. Muutoin OR-operaation tulos on 0. XOR-operaatio on mielenkiintoisempi. Lyhenne XOR tulee sanasta \"exclusive or\". XOR-operaation tulos on 1, jos jompi kumpi mutta ei molemmat operandibiteistä on 1. Muutoin XOR-tulos on 0. Toisin sanoen, XOR on 1, jos operandit ovat erilaisia."}]},{"type":"comment","value":" esimerkki bittioperaatioista "},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Esimerkki: bittioperaatiot\n\noperaatio: A and B   A or B   A xor B  not A\nA:          1100      1100     1100    1100\nB:          0101      0101     0101\ntulos:      0100      1101     1001    0011"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Bittikäskyt tekevät siis loogiset operaatiot "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"kaikille"}]},{"type":"text","value":" operandien biteille pareittain. Ne sopivat kuitenkin myös käsittelemään "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"loogisia muuttujia"}]},{"type":"text","value":", joissa on vain yksi bitti käytössä. Tällöin esimerkiksi 32-bittisen muuttujan Flag arvo on talletettu vain yhteen bittiin ja loput bitit ovat aina nollia."}]},{"type":"comment","value":" Note: xor-operaatio salakirjoituksen apuna "},{"type":"element","tagName":"text-box","properties":{"variant":"example","name":"Xor-operaatio salakirjoituksen apuna"},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Xor-operaatiota käytetään paljon salakirjoituksessa. Ajatellaan vaikkapa tilannetta, jossa lähetettävänä on salattava viesti APUA, joka käytössä olevan merkkikoodiston (UTF-8) mukaan on bitteinä 01000001_01010000_01010110_01000001. Artolla ja Beritillä on yhdessä sovittu salainen merkkijonoavain 5821, joka on bitteinä  00110011_00111000_00110010_00110001. Arto salakirjoittaa viestin tekemällä operaation APUA xor 5821. Tuloksena on bitit 01110010_01101000_01100100_01110000, mikä vastaa merkkejä rhdp.\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\nArto lähettää Beritille salakirjoitetun merkkijonon rhdp, josta kukaan ulkopuolinen ei saa selvää. Berit purkaa salakirjoituksen tekemällä uuden xor-operaation, rhdp xor 5821, jonka tuloksena on bittijono 01000001_01010000_01010110_01000001 eli alkuperäinen viesti APUA. Berit rientää apuun ja Arto on pelastettu!\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\nTämä ns. symmetrinen salakirjoitus perustuu xor-operaation ominaisuuteen, jossa kaksi xor-operaatiota samalla operandilla (avaimella 5821) kumoavat toisensa. Tällaista symmetristä salakirjoitusavainta (sama avain Artolla ja Beritillä) käytetään sinunkin pankkiyhteyksien turvaamisessa, mutta vain osana laajempaa järjestelmää."}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Bittejä käsitellään myös erilaisilla bittien siirtokäskyillä. Niissä yleensä siirretään rekisterissä olevia bittejä vasemmalle (SHL, shift left) tai oikealle (SHR, shift right) haluttu määrä. Siirron yhteydessä bittejä täytetään oikealta tai vasemmalta nollilla. Oikealle tapahtuvan normaalisiirron lisäksi usein on myös SHRA-käsky (shift right arithmetic), jossa nollan asemesta täytetäänkin vasemmalta alkuaan vasemmanpuolimmaista bittiä. Kokonaislukujen esitystavoissa etumerkki on tiedon vasemmanpuolimmainen bitti, joten SHRA-käsky säilyttää kokonaisluvun etumerkin. Tästäkin on hyötyä tietyissä ohjelmointiongelmissa!"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ttk-91:ssä on bittien siirtokäskyt SHL, SHR ja SHRA."}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Kontrollin siirtokäskyt"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Kontrollinsiirtokäskyillä voidaan (ehdollisesti) muuttaa oletusarvoista käskyjen virtaa, jossa seuraavaksi suoritettava käsky on aina edellisen perässä muistissa. Tyypillisesti tällaisia käskyjä ovat ehdottomat "},{"type":"element","tagName":"a","properties":{"href":"https://fi.m.wikipedia.org/wiki/Hyppyk%C3%A4sky","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"hyppykäskyt"}]},{"type":"text","value":" ja ehdolliset haarautumiskäskyt. Ehto voi määräytyä suoraan jonkun rekisterin perusteella vertaamalla sen arvoa nollaan. Esimerkiksi käsky voi olla "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"jneg r1, negat"}]},{"type":"text","value":". Se haarautuu osoitteeseen "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"negat"}]},{"type":"text","value":", jos rekisterin r1 arvo on negatiivinen. Toisaalta haarautuminen voi perustua aikaisemmin suoritettuun vertailukäskyyn (esim. "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"comp r1, r2"}]},{"type":"text","value":"), jonka tulos on talletettu tilarekisteriin. Tällainen käsky voisi olla vaikkapa "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"jnles loop"}]},{"type":"text","value":". Se haarautuu, jos aikaisemman vertailun tulos oli \"isompi tai yhtäsuuri\" eli \"ei pienempi\"."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Kaikki "},{"type":"element","tagName":"a","properties":{"href":"https://fi.wikipedia.org/wiki/Toistorakenne","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"silmukat"}]},{"type":"text","value":" toteutetaan myös edellä mainituilla ehdottomilla hyppykäskyillä ja ehdollisilla haarautumiskäskyillä. Vaikka korkean tason kielissä on monenlaisia silmukoita (for, while, do-until), niin konekielessä niitä on vain kahta lajia. Silmukan loppumistestaus pitää tehdä joko ennen silmukan runkoa tai sen jälkeen. Silmukka toteutetaan korkean tason kielen semantiikan (merkityksen) mukaiseksi, joten esimerkiksi C-kielessä testi on ennen silmukan runkoa ja Fortranissa rungon jälkeen. Fortran-ohjelmissa silmukan runko suoritetaan aina vähintään yhden kerran."}]},{"type":"comment","value":" for loop  esimerkki "},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Esimerkki: for-silmukka\n\nFor-loop C-kielen semantiikalla (testi silmukan alussa)\n\nfor (i=0; i<n; i=i+1) {         load   r1, =0     ; r1 on i\n    tbl[i] = 0;            loop comp   r1, n      ; kaikki tehty?\n    }                           jnles  done       ; poistu, jos valmista\n                                load   r2, =0     ; alusta Tbl[i]\n                                store  r2, tbl(r1)\n                                add    r1, =1     ; seuraava i\n                                jump   loop\n                           done ..."}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://fi.wikipedia.org/wiki/Aliohjelma","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"Aliohjelmat"}]},{"type":"text","value":", funktiot ja metodit ovat ohjelmoijan perustyökaluja ohjelmoinnissa. Niitä kutsutaan tässä kaikki yleisnimellä \"aliohjelma\". CALL-käskyllä kontrolli siirretään aliohjelmaan, eli se toimii ehdottoman hyppykäskyn tavoin ja aiheuttaa haarautumisen annettuun aliohjelmaan. Haarautumisen lisäksi se muuttaa laskentaympäristön aliohjelman omaan ympäristöön ja tallettaa paluuosoitteen johonkin. Esimerkiksi, aliohjelmassa voi olla omia muuttujia, jotka ovat käytettävissä vain aliohjelman suorituksen aikana. EXIT-käsky suorittaa paluun takaisin kutsun tehneeseen rutiiniin, kutsua seuraavaan konekäskyyn. Se myös palauttaa laskentaympäristön ennalleen."}]},{"type":"comment","value":" funktion kutsu esimerkki  "},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Esimerkki: funktion kutsu\n\nC-kieli               konekieli\n\nx = sum(y, z);        push  sp, y    ; laita parametrin y arvo pinoon\n                      push  sp, z    ; laita parametrin z arvo pinoon\n                      call  sp, sum  ; kutsu fuktiota Sum\n                      pop   sp, r1   ; ota funktion paluuarvo pinosta\n                      store r1, x    ; talleta paluuarvo muuttujan x arvoksi"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Käyttöjärjestelmän palvelupyynnöt (SVC, supervisor call) ovat hyvin samankaltaisia aliohjelmakutsujen kanssa, mutta kuitenkin vähän erilaisia. Suorittimen suoritustila muuttuu etuoikeutetuksi ja kutsun yhteydessä täytyy tarkistaa, onko ohjelmalla oikeus kutsua tätä palvelua vai ei. Palvelusta palataan lopulta omalla paluukäskyllä (esim. IRET, interrupt return)."}]},{"type":"comment","value":" svc kutsu "},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Esimerkki: svc kutsu\n\nC-kieli         konekieli\n\nprint(x);       load  r1, x      ; laita tulostettava arvo rekisteriin r1\n                svc   sp, =print ; kutsu käyttöjärjestelmäpalvelua Print"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ttk-91:ssä on ehdoton hyppykäsky JUMP. Siellä on myös rekisterin nolla-arvoon vertailuun perustuvat haarautumiskäskyt JNEG, JZER, JPOS, JNNEG, JNZER ja JNPOS. Siellä on kahden operandin vertailukäsky COMP tilanteisiin, jossa vertailun kohde on nollasta poikkeava.  Vertailun tulokseen perustuva haarautumiskäskyt ovat JLES, JEQU, JGRE, JNLES, JNEQU ja JNGRE. Nämä haarautumiset vaativat siis aina kahden konekäskyn suorittamisen."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ttk-91:ssä on aliohjelmia ja käyttöjärjestelmän palvelupyyntöjä varten CALL, EXIT ja SVC-käskyt. Mitään IRET-käskyä ei ole, koska määrittely ei ole täydellinen. Aliohjelmia ei käsitellä tällä kurssilla tämän enempää."}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"I/O-käskyt"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I/O-laitteiden käyttö on vaikeata, koska siinä pitää synkronoida toiminta suorittimen ulkopuolisen laitteen kanssa. Yleensä sen tekevät vain käyttöjärjestelmän laiteajurit etuoikeutetussa tilassa. Yksinkertaisille laitteille voi olla omat (etuoikeutetut) konekäskynsä I/O:n tekemiseen. Monimutkaisempien I/O-laitteiden kontrollointia I/O-laitteen oma muisti näkyy keskusmuistin tavoin ohjelman käyttämässä muistiavaruudessa. Laiteajuri voi sitten kirjoittaa sinne dataa ja komentoja sekä lukea laitteen tilatietoa tavallisilla load/store-käskyillä. Emme käsittele I/O:n toteutusta tämän tarkemmin tällä kurssilla."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ttk-91:ssä on IN-käsky tiedon lukemiseen näppäimistöltä ja OUT-käsky tiedon kirjoittamiseen näytölle. Näitä voi käyttää tavallisessa suoritustilassa, koska ttk-91:ssä ei muita suoritustiloja ole edes määritelty."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Syötteen lukeminen käyttäjältä"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ttk-91:ssä käyttäjän syötteen tulee aina olla kokonaisluku. Konekäskyllä"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"IN R3, =KBD"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"saadaan luettua tulosrekisteriin rekisteriin R3 käyttäjän syötteenä antama kokonaisluku. Sallittuja rekistereitä IN-käskyn kanssa käytettäessä ovat R0 - R5. Rekisterit R6 (SP) ja R7 (FP) ovat varattu erikoistarkoituksia varten (pino-osoitin ja kehysosoitin)."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Kokonaisluvun tulostaminen"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ttk-91:ssä tulostaminen näytölle rekisteristä R3 tehdään seuraavasti:"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"OUT R3, =CRT"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Rekisteri voi olla R3:n sijasta myös R0 - R7 eli R0 - R5, SP tai FP."}]},{"type":"comment","value":" IO käsky esimerkki  "},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Esimerkki: I/O-käskyt\n\nC-kieli       konekieli\n\nPrint(x);     load  r1, x    ; laita tulostettava arvo rekisteriin r1\n              out   r1, =crt ; tulosta r1 arvo näytölle konekäskyllä out\n"}]}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Erityiskäskyt"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Suorittimella on lisäksi sekalainen joukko suorittimen ja järjestelmän hallintaan liittyviä konekäskyjä. Useissa suorittimissa on erikoinen käsky NOP (no operation), mikä ei nimensä mukaisesti tee mitään. Se kuitenkin haetaan käskyjen nouto- ja suoritussyklissä normaalisti, joten se kuluttaa aikaa. Jossain tapauksissa tämä on helpoin tapa rytmittää asioita oikein."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Suorittimissa voi olla rekisterissä olevien 1-bittien lukumäärän laskemiskäsky, jota tarvitaan joidenkin salakirjoitusjärjestelmien yhteydessä tai niiden murtamiseen. Suorittimissa voi olla (etuoikeutettuja) käskyjä eri välimuistien tyhjentämiseen. Etuoikeutettuja käskyjä on myös kanta- ja rajarekistereiden lukemiseen ja asettamiseen, samoin kuin muidenkin sisäisten muistinhallintarekistereiden käsittelyyn."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ttk-91:ssä on NOP-käsky. Siinä ei ole muita erityiskäskyjä, koska määrittely ei ole täydellinen."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"— erityiskäskyesimerkki"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Esimerkki: NOP-käsky\n\nC-kieli           konekieli\n\nif (x<y)                 load r1, x    -- onko x<y?\n  y = x;                 comp r1, y\n                         jnles  jatka  -- ei ole, ohita store\n                         store r1, y\n                  jatka  nop           -- nop-käskyyn voi hypätä"}]}]}]},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Symbolisen konekielen kääntäjän ohjauskäskyt, valekäskyt"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ohjelmien symbolisen konekielisessä esitystavassa on suorittimen konekäskyjen lisäksi mukana myös kääntäjän ohjauskäskyjä. Niiden avulla ilmaistaan mm. tilanvarauksia muuttujille ja muille tietorakenteille sekä nimiä halutuille vakioarvoille. Näitä kutsutaan joskus myös "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"valekäskyiksi"}]},{"type":"text","value":", koska ne näyttävät tavallisilta käskyiltä, mutta niistä ei tule mitään suoritettavaa konekäskyä. Ne vaikuttavat vain ohjelman kääntämisen tai latauksen aikana."}]},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"Muuttujien, taulukoiden ja vakioiden määrittelyn ohjauskäskyt ttk-91 symbolisessa konekielessä"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Muuttujan tilanvaraus"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Muuttujan tai vakion tilanvarauskäsky on DC (data constant). Esimerkiksi muuttujan Anna tilanvaraus ja alkuarvon asettaminen tehdään kirjoittamalla ohjelmaan näin:"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Anna DC 200"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Käännösvaiheessa kääntäjä varaa muuttujalle "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Anna"}]},{"type":"text","value":" yhden muistipaikan ohjelman sisäisessä muistiavaruudeta ja asettaa sen muistipaikan arvoksi 200. Käännöksessä kääntäjä käyttää hyväksi "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"symbolien"}]},{"type":"text","value":" arvoa. Kääntäjä asettaa "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"symbolitauluun"}]},{"type":"text","value":" symbolin Anna arvoksi muuttujan Anna osoitteen."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"Huomaa, että kun käännösvaiheessa puhutaan muistipaikoista, muistiosoitteista ja osoitteista, niillä tarkoitetaan aina ohjelman sisäisen muistiavaruuden osoitteita, jotka alkavat nollasta ja päättyvät ohjelmalle varattuun kokoon vähennettynä yhdellä. Vasta ohjelmaa suorittaessa muistinhallintayksikkö MMU muuntaa ohjelman sisäisen muistiavaruuden osoitteen fyysiseksi keskusmuistiosoitteeksi."}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Oletetaan, että muuttujan Anna osoite on 1000 ja ohjelmakoodissa on seuraava konekäsky:"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"LOAD R1, Anna"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tällöin kääntäjä kääntää tämän käskyn ikään kuin se olisi:"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"LOAD R1, 1000"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Taulukon tilanvaraus"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Taulukko on tietorakenne, joka koostuu peräkkäisistä muistipaikoista. Taulukon tilanvaraus tehdään tilanvarauskäskyllä DS (data segment). Esimerkiksi tilanvaraus taulukolle "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Arvosanat"}]},{"type":"text","value":" saadaan tehtyä seuraavasti."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Arvosanat DS 30"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tällöin kääntäjä varaa taulukolle 30 peräkkäistä muistipaikkaa ja asettaa symbolin "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Arvosanat"}]},{"type":"text","value":" arvoksi taulukon ensimmäisen osoitteen."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Oletetaan, että tuo alkuosoite on 1001 ja että ohjelmakoodissa on seuraava käsky:"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"STORE R1, Arvosanat(R3)"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tällöin kääntäjä kääntää sen kuin ohjelmakoodissa olisi lukenut:"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"STORE R1, 1001(R3)"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Koska ttk-91:ssä on käytössä "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"indeksoitu muistiinosoitus"}]},{"type":"text","value":", tuo konekäsky tallentaa rekisterin R1 arvon osoitteeseen, joka saadaan laskemalla 1001 + R3 eli 1001 + rekisterin R3 arvo. Jos rekisterin R3 arvo on ennen tuon käskyn suorittamista 20, niin tällöin tuo konekäsky tallentaa rekisterin R1 arvon osoitteeseen 1001+20\\ = 1021."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Symbolin arvon määrittäminen"}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Joskus on kätevää määritellä ohjelmoidessa joitakin vakioita, jotka kuitenkin muunnetaan jo käännösvaiheessa kokonaisluvuiksi. Tätä varten ttk-91-kääntäjässä on käytössä ohjauskäsky "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"EQU"}]},{"type":"text","value":". Sitä käytetään seuraavasti ohjelmakoodissa:"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"VASTAUS EQU 42"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tällöin kääntäjä asettaa symbolitauluun symbolin "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"VASTAUS"}]},{"type":"text","value":" arvoksi 42. Oletetaan, että ohjelmassa on lisäksi tällainen rivi:"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"COMP R2, =VASTAUS"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Tällöin kääntäjä kääntää kyseisen konekäskyn ikään kuin siinä olisi lukenut seuraavasti:"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"COMP R2, =42"}]}]}]},{"type":"comment","value":" ttk91 ohjelmaesimerkki "},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"Ttk-91 ohjelmaesimerkki"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Ttk-91 ohjelmaesimerkki\n\nLaske taulukon tbl alkioiden arvojen summa muuttujan sum arvoksi. Tulosta\nmuuttujan sum arvo.\n\n                   -- tilanvaraukset\nsum    dc    0        -- määr. ja varaa tilaa muuttujalle sum, alkuarvo 0\n                      -- symbolin sum arvo on muuttujan sum osoite\ntbl    ds   20        -- määrittele ja varaa tilaa 20-alkioiselle\n                      -- taulukolle tbl.\n                      -- symbolin tbl arvo on taulukon ensimmäisen\n                      -- alkion tbl[0] osoite\nlkm    equ  20        -- määrittele symboli lkm, jolla arvo 20\n\nstart  ...            -- aloita ohjelman suoritus\n       ...            -- alusta taulukko tbl jollain tavalla\n\n                      -- alusta summan laskeminen\n      load r3, =lkm      -- r3=raja-arvo, aseta arvo  (välitön tied.os.)\n      load r2, =0        -- r2=indeksi i, alkuarvo 0  (välitön tied.os.)\n      load r1, =0        -- r1=summa, alkuarvo 0      (välitön tied.os.)\n                      -- vertaa ja laske summaa\nloop  comp r2, r3        -- vertailun tulos tilarekisteriin (väl. tied.os.)\n      jeq done           -- poistu silmukasta lopuksi       (väl. tied.os.)\n      add r1, tbl(r2)    -- lisää tbl[i] summaan           (suora muistiv.)\n                      -- seuraava alkio\n      add r2, =1         -- lisää indeksiin r2 luku 1   (välitön tiedonos.)\n      jump loop          -- palaa testaamaan            (välitön tiedonos.)\n                      -- tallenna ja tulosta summa\ndone  store r1, sum      -- tallenna summa muuttujaan sum  (suora muistiv.)\n      load  r4, sum      -- lue r4:ään muuttujan sum arvo  (suora muistiv.)\n      out   r4, =crt     -- tulosta r4:n arvo näytölle   (välitön tied.os.)\n                      -- lopeta ohjelman suoritus\n      svc   sp, =halt    -- kutsu käyttöjärj.palv. 11    (välitön tied.os.)"}]}]}]},{"type":"comment","value":" Note: Ttk-91 simulaattori Titokone  -- onko OK laittaa näkyville? Entä TitoTrainer?  "},{"type":"element","tagName":"text-box","properties":{"variant":"example","name":"Titokone"},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://www.cs.helsinki.fi/group/titokone/","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"Titokone"}]},{"type":"text","value":" on kevällä 2004 Helsingin yliopistossa opiskelijoiden harjoitustyönä toteuttama ohjelmisto, jonka avulla voidaan kääntää ja suorittaa symbolisella konekielellä kirjoitettuja ohjelmia Auvo Häkkisen vuonna 1991 opetuskäyttöä varten määrittelemälle ttk-91 tietokoneelle. Titokone-ohjelmistoon sisältyy symbolisen konekielisen ohjelmoinnin ohjelmistonkehitysympäristö sekä suorituksen simulaattori ja animaattori.\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\nTitokone löytyy verkkosivulta "},{"type":"element","tagName":"a","properties":{"href":"https://www.cs.helsinki.fi/group/titokone/","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"https://www.cs.helsinki.fi/group/titokone/"}]},{"type":"text","value":". Helpoin tapa ajaa Titokonetta on tallettaa verkkosivulta löytyvä jar-tiedosto ("},{"type":"element","tagName":"a","properties":{"href":"https://www.cs.helsinki.fi/group/titokone/distr/titokone-1.203.jar","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"titokone-1.203.jar"}]},{"type":"text","value":") omalle koneellesi ja avata se. Verkkosivulta löytyy myös Titokoneen käyttöohjeet. Valmiita esimerkkejä ttk-91 symbolisen konekielen ohjelmista löytyy verkkosivulta "},{"type":"element","tagName":"a","properties":{"href":"http://www.cs.helsinki.fi/group/nodes/kurssit/tito/esimerkit","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"http://www.cs.helsinki.fi/group/nodes/kurssit/tito/esimerkit"}]},{"type":"text","value":".\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\nTällä kurssilla ei mitenkään edellytetä konekielisen ohjelmoinnin harjoittelua Titokoneella. Se voi kuitenkin olla hauskaa, kuten kaikki muukin ohjelmointi. Malta kuitenkin jatkaa kurssin läpikäyntiä, äläkä jää huvittelemaan Titokoneen kanssa."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Kurssilla Tietokoneen toiminnan jatkokurssi 2022 tutustutaan tarkemmin ttk-91-ohjelmointiin ja TitoTrainer-oppimisympäristössä tehdyt ohjelmointitehtävät ovat osa kurssisuoritusta. Voit halutessasi jo harjoitella ohjelmointia ja suorittamasi tehtävät huomioidaan tuolla jatkokurssilla."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"TitoTraineriä käytetään osoitteessa "},{"type":"element","tagName":"a","properties":{"href":"http://titotrainer2.users.cs.helsinki.fi/","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"http://titotrainer2.users.cs.helsinki.fi/"}]},{"type":"text","value":". Voit luoda sinne oman tunnuksen ja valita kurssiksi MOOC 2022. Valitse mahdollisimman yksilöllinen tunnus, sillä jos jokin tunnus on jo aiemmin olemassa, TitoTrainer ei välttämättä kerro sitä, vaan ilmoittaa jostakin muusta virheestä."}]}]},{"type":"comment","value":" quiz 2.3.1-9 Konekäsky- ja bittitehtäviä "},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"147ae495-671a-5860-b4a3-325b4de3d516"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"c755c8de-24b9-5af4-b242-3e18aaf648f5"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"5cf3ff62-21c5-5ba4-950b-dba748cd8570"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"bdf43b38-a75b-579f-b456-d0e9eff1262a"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"7e6d4434-ba27-558d-b776-62b76c9d5eb7"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"27ba6814-1c57-572e-b0cf-fd0b9100570d"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"786d8194-beb1-55e7-ba0b-89f9e8ff3db4"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"2f8ab620-b418-5fad-bd06-3f4f6bfdbecb"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"3c9acabf-b3d3-5a3d-a395-aac1295770ba"},"children":[]}]}]},"html":"<div><div>\n<lead>Tässä osiossa tutustumme tarkemmin konekäskyihin. Selvitämme mm., mitä ominaisuuksia konekäskyissä on ja minkälaisia konekäskyjä suorittimissa voi olla. Esittelemme samalla myös (osan) esimerkkitietokoneen ttk-91 käskyistä ja annamme esimerkkejä (symbolisesta) konekielisestä koodista.</lead>\n</div><h2>Konekäskykanta</h2><p>Suorittimen kaikki konekäskyt yhdessä muodostavat sen konekäskykannan, joka on käyttöliittymä suorittimella tapahtuvaan laskentaan. Laskenta tapahtuu suorittimen rekistereiden välillä ja konekäskyissä yleensä nimetään kaikki sen käyttämät rekisterit.</p><h3>Rekistereiden lukumäärä konekäskyssä</h3><p>Yksi tapa luokitella konekäskykantoja perustuu siihen, kuinka monta operandia konekäskyjen aritmetiikkaoperaatioissa voi nimetä. Joissakin tapauksissa riittää yhden operandin nimeäminen. Tällöin toinen operandi ja tulos ovat aina yksi ja sama oletusarvoinen \"akkurekisteri\". Sen arvo tulee väkisten tuhottua operaation aikana, koska uusi tulos kirjoitetaan samalle paikalle akkurekisteriin.</p><p>Useissa konekielissä käskyssä voi aritmetiikkaoperaatioissa nimetä kaksi operandia. Toinen niistä on samalla tulosrekisteri. Tässäkin tapauksessa on se huono piirre, että toinen operandi tuhoutuu käskyn suorituksen aikana. Hyvänä ominaisuutena on kuitenkin se, että näissä prosessoreissa on useampi rekisteri, joten ongelma ei ole niin suuri.</p><p>Nykyisissä konekielissä on yleistä, että operandeja on aritmetiikkaoperaatioissa nimetty kolme kappaletta ja ne ovat kaikki rekistereitä. Näin kummankaan operandin arvoa ei tarvitse tuhota, ellei sitä erityisesti haluta nimeämällä tulosrekisteri samaksi kuin toinen operandirekistereistä. Nämä suoritinarkkitehtuurit ovat yleensä ns. <em>load-store arkkitehtuureja</em>, joissa muistiviittauksia tekevät käskyt eivät tee samalla aritmeettis-loogisia operaatioita.</p><p>On myös määritelty konekäskykantoja, joissa aritmetiikkaoperaatioissa ei ole nimetty lainkaan rekistereitä. Tuollaiset koneet ovat ns. <em>pinokoneita</em>, joissa laskenta tapahtuu <em>pinoa</em> käyttäen. Pinon voi mieltää pöydällä olevaksi korttipakaksi. Operandit löytyvät pinon pinnalta ja tulos talletetaan myös pinoon. Esimerkiksi yhteenlaskun yhteydessä pinosta poistetaan (päältä) kaksi arvoa operandeiksi, arvot lasketaan yhteen ja tulos talletetaan pinoon päällimmäiseksi. Pino on talletettu muistiin ja sen pinnalle osoittaa sisäinen pinorekisteri (SP, Stack Pointer). Korttipakkaesimerkkiä käyttäen yhteenlaskussa otamme pinon pinnalta kaksi korttia (ruutu 5 ja hertta 3) ja laitamme takaisin niiden arvojen summan (pata 8). Esimerkki ei toimi, jos pinon pinnalla on vain kuvakortteja, koska pelikorttien arvoalue on niin pieni.</p><p>Esimerkkikoneessa ttk-91 voi yhdessä konekäskyssä nimetä kaksi operandia, joista ensimmäinen on aina rekisteri. Toinen operandi voi olla joku rekisteri, se voi olla vakio, tai se voidaan määritellä näiden yhdistelmänä. Se voi olla myös muistissa, kuten seuraavassa on tehty.</p><p>Load-store arkkitehtuurin koodissa on paljon konekäskyjä, mutta sen suoritus voi olla hyvin nopeaa. Laskenta on erikseen muistioperaatioista ja suorittimella on riittävästi rekistereitä koodin suoritusnopeuden optimoimiseksi. Fiksu suoritin voisi osata noutaa A:n ja B:n arvot osittain samanaikaisesti muistista, koska käskyt ovat täysin riippumattomia toisistaan.</p><!-- esimerkki Yhteenlasku eri tyyppisillä suorittimilla --><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Yhteenlasku eri tyyppisillä suorittimilla\n\nLaske C=A+B, kun A, B ja C ovat muuttujia muistissa eri\ntyyppisillä suorittimilla. Operandien lukumäärä\nADD-käskyssä on 0, 1, 2 tai 3.\n\nPinokone   Akkurek.    Ttk-91        Load-store\n(0 oper.)  (1 oper.)   (2 oper.)     (3 oper.)\n\npush A     load  A     load  r4,A    load  r10,A\npush B     add   B     add   r4,B    load  r11,B\nadd        store C     store r4,C    add   r12,r10,r11\npop C                                store r12,C</code></pre></div><p>Olisi mukava, jos nopeita rekistereitä olisi paljon, koska tiedot löytyisivät tällöin usein mahdollisimman nopeasti. Suuri määrä rekistereitä kuitenkin tarkoittaa, että tarvitsemme enemmän bittejä niiden osoittamiseen konekäskyissä. Jos rekistereitä on 16, niin neljä bittiä riittää rekisterin osoitteeksi. Toisaalta, 128 rekisterille tarvitaan jo 7 bittiä niiden osoittamiseen. Tuolloin kolmen rekisterin nimeämiseen kuluu jo 21 bittiä, mikä tekee konekäskyistä ehkä turhan pitkiä. Usein rekistereitä on 16-32 kappaletta kutakin eri tyyppiä, jolloin yhden rekisterin nimeämiseen riittää 4-5 bittiä konekäskyissä.</p><p>Esimerkkikoneessa ttk-91 on 8 rekisteriä, joten niiden nimeämiseen konekäskyssä tarvitaan 3 bittiä. Konekäskyssä voi viitata kahteen rekisteriin. Jälkimmäistä rekisteriä sanotaan <em>indeksirekisteriksi</em>, koska sitä voidaan käyttää indeksinä taulukkoviitauksissa.</p><h3>Eri tavat viitata muistiin</h3><p>Konekäskyssä tarvitaan jonkinlaisia tapoja viitata muistiin. Korkean tason kielissä usein käytetyt tietotyypit voivat vaatia erilaisia viittaustapoja. Yleisiä tietotyyppejä korkean tason kielissä ovat muuttujat, vakiot ja 1-, 2- tai 3-ulotteiset taulukot. Sellaisia ovat myös <em>tietueet</em> tai <em>oliot</em>, joissa on erilaisia kenttiä. Usein tieto on myös esitetty epäsuorasti, jolloin tietorakenteessa ei olekaan itse tietoa, vaan ainoastaan osoite tietoon.</p><!-- Note: tietue ja olio --><text-box variant=\"example\" name=\"Tietueet ja oliot\"><p>Tietue on esimerkki rakenteisesta tiedosta. Esimerkiksi harrasteseuran jäsenrekisteri voisi koostua tietueista, joista kukin kertoo yhden jäsenen tiedot. Kullakin tietueella on sama rakenne ja se sisältää samat (tieto)kentät. Tällaisia kenttiä olisivat esimerkiksi jäsenen nimi, osoite ja puhelinnumero.\n<br><br>\nOlio on kehittyneempi muoto tietueesta. Siellä on tiedon lisäksi myös kokoelma metodeja (aliohjelmia, funktioita), joiden avulla olion tietoja voidaan lukea ja muokata. Tyypillisesti olion tietoja voi lukea tai kirjottaa vain sen omien metodien kautta. Tämä tekee helpommaksi ja luotettavammaksi olion tietojen käytön, kun kaikki samaa tietoa käsittelevä koodi on keskitetty yhteen paikkaan. Koodausvirheiden havaitseminen on helpompaa verrattuna tilanteeseen, jossa samaa tietoa käsiteltäisiin siellä täällä esimerkiksi 40000 koodirivin ohjelmistossa. Jos harrasteseuran jäsenrekisteri toteutettaisiin oliona (esim. JäsR), niin jäsenten tiedot olisivat olion sisäisiä tietorakenteita ja niitä pääsisi käyttämään ainoastaan olion metodeja kutsumalla. Tällaisia metodeja olisivat esimerkiksi JäsR.UusiJäsen(), JäsR.LueOsoite() ja JäsR.MuutaOsoite() avulla.</p></text-box><p>Olisi mukavaa, jos tietoon useimmiten pystyisi viittaamaan yksinkertaisesti yhden käskyn sisältä jotain suorittimella toteutettua muistinviittaustapaa käyttäen. Aina tämä ei ole mahdollista. Tällöin viitattu muistiosoite lasketaan ensin johonkin rekisteriin suorittamalla usea konekäsky ja sitten vihdoin itse muistiviite voidaan toteuttaa yhdellä konekäskyllä tuon rekisterin kautta. Tyypillisesti näin tehdään vaikkapa viitatessa 3-ulotteisen taulukon alkioihin, koska juuri missään suorittimessa ei ole valmista muistinviittaustapaa 3-ulotteisille taulukoille.</p><p>Viitattu tieto voi sijaita tietyssä muistiosoitteessa, joten konekäskyssä olisi mukava olla suoraan paikka tuolle osoitteelle. Joissakin korkean tason kielissä (esim. C) on <em>pointtereita</em> eli <em>osoitinmuuttujia</em>, jotka eivät sisällä itse tietoa vaan ainoastaan tiedon osoitteen muistissa. Tietoon viitatessa pitää ensin hakea muistista pointterin arvo ja vasta sitten sen avulla hakea muistista laskennassa tarvittava data. Kyseessä on tällöin <em>epäsuora muistiviite</em>. Useissa korkean tason ohjelmointikielissä (esim. Java) taas ei tietoisesti ole pointtereita, koska niiden käyttö on vaativaa ja johtaa helposti ohjelmointivirheisiin.</p><p>Usein osoite voi olla suhteellinen jonkin rekisterin suhteen. Viitatun tiedon osoite saadaan nyt laskemalla yhteen tuon rekisterin ja jonkin vakion arvot yhteen. Tällaista kutsutaan <em>indeksoiduksi tiedonosoitukseksi</em>. Esimerkiksi 1-ulotteisten taulukoiden tapauksessa tuo vakio voi olla taulukon alkuosoite muistissa ja rekisterin arvo kyseisen taulukon <em>indeksi</em>. Toisaalta taas tietueen tai olion tapauksessa rekisterissä on yleensä tietueen tai olion muistiosoite, ja vakiona on viitatun kentän suhteellinen osoite tietueessa tai oliossa. On hyvin käytännöllistä, että samalla tiedonosoitustavalla voidaan ratkaista kahden hyvin yleisen mutta silti erilaisen tietorakenteen käyttö. Lähes kaikissa suorittimissa on indeksoitu tiedonosoitus käytettävissä.</p><p>Muistiosoitteen laskennassa voidaan myös käyttää useampaa rekisteriä ja näin viitata esimerkiksi 2-ulotteisen taulukon alkioon hyvin helposti. Tällainen tiedonosoitustapa on kuitenkin nykyään harvinainen, koska se on niin monimutkainen muihin tapoihin verrattuna. Yksinkertaisien konekäskyjen suoritusnopeus on helpompi optimoida kuin monimutkaisten tiedonosoitustapojen.</p><p>Esimerkkikoneessa ttk-91 on kolme tiedonosoitustapaa ja ne perustuvat kaikki indeksoituun tiedonosoitukseen. Ensin lasketaan ohjelman käyttämä \"muistiosoite\" laskemalla yhteen käskyssä oleva vakio ja käskyssä olevan <em>indeksirekisterin</em> arvo. Jos \"osoite\" löytyy suoraan indeksirekisteristä, niin vakioksi laitetaan nolla. Jos \"osoitteeksi\" haluttiin pelkästään käskyssä oleva vakio, niin tämä on koodattu käskyyn laittamalla indeksirekisteriksi R0. Indeksirekisteriä R0 ei tämän vuoksi voi käyttää indeksointiin.</p><p>Ttk-91:n suorittimella on kolme vaihtoehtoista tapaa saada jälkimmäinen operandi edellä lasketun \"muistiosoitteen\" avulla ja ne valitaan 2-bittisen <em>tiedonosoitusmoodin</em> avulla. Moodin arvo 0 (<em>välitön tiedonosoitus</em>) tarkoittaa, että tuo äsken laskettu \"muistiosoite\" on sellaisenaan toinen operandi, eikä mitään muistiviitettä tarvita. Moodin arvo 1 (<em>suora muistiviite</em>) tarkoittaa, että muistiosoitetta käytetään yhden kerran operandin hakemiseksi muistista. Moodin arvo 2 (<em>epäsuora muistiviite</em>) tarkoittaa, että ensin haetaan muistista edellä laskettua muistiosoitetta käyttäen toisen operandin osoite ja vasta sitten haetaan muistista tuota osoitetta käyttämällä jälkimmäinen operandi.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Esimerkki: Ttk-91 käskyn toisen operandin arvon nouto TR:ään. Oletetaan, että käskyrekisterissä IR on jokin ttk-91 konekäsky. Suoritin toteuttaa seuraavat vaiheet kontrolliyksikön käskyttämänä:\n\n\n\nKopioi käskyn vakiokentän arvo tilapäisrekisteriin TR.\n\nJos käskyn oikeanpuoleisen rekisterin numero eri kuin 0:\n    Laske operandin tosiasiallinen osoite (tai arvo) seuraavasti:\n        Kopioi käskyn oikeanpuoleisen rekisterin arvo ALU:n operandiksi 1,\n        Kopioi rekisterin TR arvo ALU:n operandiksi 2,\n        Anna ALU:lle kontrollijohtimia pitkin komento &quot;add&quot;,\n        Odota vähän aikaa,\n        Kopioi ALU:n ulostulo rekisteriin TR.\n        (Nyt operandin tosiasiallinen osoite (tai arvo) on TR:ssä.)\n\nJos käskyn moodi-kentän arvo on vähintään 1,\n    Kopioi TR:n arvo rekisteriin MAR,\n    Anna väylän kontrollirekisterille (Bus Ctl) komento &quot;Read&quot;,\n    Odota vähän aikaa, että arvo saapuu muistista väylää pitkin MBR:ään.\n    Kopio rekisterin MBR arvo rekisteriin TR.\n\nJos käskyn moodi-kentän arvo on vähintään 2,\n    Kopioi TR:n arvo rekisteriin MAR,\n    Anna väylän kontrollirekisterille (Bus Ctl) komento &quot;Read&quot;,\n    Odota vähän aikaa, että arvo saapuu muistista väylää pitkin MBR:ään.\n    Kopio rekisterin MBR arvo rekisteriin TR.\n\nJos käskyn moodi-kentän arvo on vähintään 3,\n    Aiheuta virhetilanne (&quot;Bad Mode&quot;) ja keskeytä käskyn suoritus.</code></pre></div><p>Ttk-91 koneen symbolisessa konekielessä <em>välitön tiedonosoitus</em> kuvataan ennen vakio-osaa olevalla '='-merkillä. <em>Epäsuora muistiviite</em> kuvataan vastaavasti ennen vakio-osaa olevalla '@'-merkillä, kun <em>suorassa muistiviitteessä</em> vakio-osa on sellaisenaan ilman mitään erikoismerkkejä.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Esimerkki: Ttk-91 symbolisen konekielen tiedonosoitusmoodi\n\nOletetaan, että kaikissa käskyissä alkuaan rekisterin r1 arvo\non 3, rekisterin r2 arvo on 10, muistipaikan mem(17) arvo on 45,\nja että muistipaikan mem(45) arvo on 88.\n\n               op.koodi rek-1   moodi ind.rek. vakio  tulos\nload r1, r2      -- 2      1        0     2        0    r1 &lt;- 10\nload r1, =7      -- 2      1        0     0        7    r1 &lt;- 7\nload r1, =7(r2)  -- 2      1        0     2        7    r1 &lt;- 17\nload r1, 7(r2)   -- 2      1        1     2        7    r1 &lt;- 45\nload r1, @7(r2)  -- 2      1        2     2        7    r1 &lt;- 88\nstore r1, 7(r2)  -- 1      1        0     2        7  mem(17) &lt;- 3\nstore r1, @7(r2) -- 1      1        1     2        7  mem(45) &lt;- 3</code></pre></div><p>Käskyn moodi-kentän arvon kertoo siis muistista <em>lukujen</em> lukumäärän käskyn suoritusaikana. Muistiin kirjoituskäskyn (STORE) yhteydessä moodikentän arvo on yhtä pienempi kuin vastaavassa muistin lukukäskyssä (LOAD) ja sillä tarkoitetaan aina suoraa tai epäsuoraa muistiviitettä. Käskyn suoritusaikana STORE-käskyssä tulee lopuksi aina yksi muistiin <em>kirjoitus</em>.</p><h3>Konekäskyjen pituus ja muoto</h3><p>Vaihtelevasta konekäskyjen pituudesta on se hyöty, että eri käskyillä voi olla erilaisia kenttiä. Esimerkiksi pelkästään rekistereiden välillä operoiva konekäsky ei tarvitse vakio-kenttää, mutta muistinviittauksen yhteydessä vakiokentästä taas olisi hyötyä. Joissakin tapauksissa vakiokenttä voisi olla kovinkin lyhyt (esim. 8 bittiä), kun taas muistisoitteiden tapauksissa se voisi olla jopa 32-bittinen tai pidempikin. Vaihtelevasta konekäskyjen pituudesta on kuitenkin myös haittaa. Käskyjen nouto muistista on vaikeata, kun ei heti tiedetä mitenkä monta tavua tarvitsee noutaa. Tavujen määrä selviää vasta kun operaatiokoodi on ensin haettu muistista. Tämän vuoksi nykyään yleensä käytetään usein vain vakiomittaisia konekäskyjä.</p><p>Konekäskyjä voi olla useata eri muotoa. Absoluuttinen hyppykäsky ei tarvitse operaatiokoodin lisäksi kuin hyppyosoitteen. Muistiviittauskäskyt voivat käyttää erilaisia muistinviittausmuotoja, joista jotkut käyttävät rekistereitä apunaan ja jotkut eivät. Aritmeettis-loogisissa operaatioissa voidaan tarvita yksi, kaksi tai kolme nimettyä rekisteriä. Yleensä konekäskyn muoto määräytyy suoraan sen operaatiokoodin perusteella, mutta joissakin konekielissä jokaisen operandin muoto voi määräytyä erikseen.</p><p>Esimerkkikoneen ttk-91 kaikki konekäskyt ovat 32-bittisiä ja niillä on kaikilla sama muoto: operaatiokoodi 8 bittiä, operandi/tulosrekisteri 3 bittiä, tiedonosoitusmoodi 2 bittiä, indeksirekisteri 3 bittiä ja vakiokenttä 16 bittiä. Tiedonosoitusmoodin käyttö voi tuntua aluksi sekavalta, mutta käytännön ohjelmoinnissa eri tiedonosoitusmoodeja tarvitaan koko ajan. Tällä kurssilla emme perehdy varsinaiseen konekieliseen ohjelmointiin muutamaa triviaalia esimerkkiä enempää.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Esimerkki: Ttk-91 symbolisen konekielen käskyjen talletusmuoto\n\n     kentät:      op.koodi tul.rek. moodi ind.rek. vakiokenttä\n     bittejä:        8        3       2      3        16\n\n    -- Hae X:n arvo muistista rekisteriin r1.\n    -- Muuttujan X osoite on sama kuin symbolin X arvo.\nload r1, X         2 (load)     1      1     0     X:n osoite\n\n    -- Lisää r2:n arvoon luku 6\nadd  r2, =6        17 (add)     2      0     0     6\n\n    -- Kerro r4:n arvo muistissa olevan taulukon Tbl alkion i arvolla,\n    -- kun i on r1:n arvo.\n    -- Taulukon Tbl osoite on sama kuin symbolin Tbl arvo.\nmul  r4, Tbl(r1)   19 (mul)     4      1     1     Tbl:n osoite\n\n    -- Jaa r3:n arvo luvulla, jonka osoite on muistissa\n                              osoitinmuuttujan ptrX arvona.\n    -- Osoitinmuuttujan ptrX osoite on sama kuin symbolin ptrX arvo.\ndiv  r3, @ptrX     20 (div)     3      2     0     ptrX:n osoite\n\n    -- Hyppää osoitteeseen loop, jos r2:n arvo on &lt;0.\n    -- Silmukan loop osoite on sama kuin symbolin loop arvo\njpos  r2, loop     35 (jpos)    2      0     0     loop&#39;in osoite\n\n    -- Talleta r2:n arvo muistissa olevan muuttujan Y arvoksi.\n    -- Rekisterin r2 arvo säilyy ennallaan.\n    -- Muuttujan Y osoite on sama kuin symbolin Y arvo.\nstore r2, Y        1 (store)    2      0     0     Y:n osoite</code></pre></div><h3>Tiedon tyypit</h3><p>Tietokone osaa (tietenkin) käsitellä kaiken tyyppistä tietoa. Suoritin ymmärtää kuitenkin vain muutamaa tietotyyppiä, joita varten on omat konekäskynsä. Kaikki muu tieto pitää kuvata näiden muutaman tietotyypin avulla. Sellaisen tiedon käsittely tapahtuu ohjelmallisesti, yleensä kutakin tietotyyppiä varten erikseen suunniteltujen aliohjelmien avulla.</p><p><em>Kokonaisluvut</em> ovat yleensä kaikissa suorittimissa. Useissa on kokonaislukuja muutamaa eri pituutta, esimerkiksi 8-, 16-, 32  ja 64-bittisiä. On ehkä yllättävää, että kaikki tietokoneella ratkaistavissa olevat ongelmat voidaan ratkaista pelkästään kokonaislukujen avulla. Se ei ole kuitenkaan yksinkertaisin tai tehokkain tapa.</p><p>Missään suorittimessa ei ole reaalilukuja. Esimerkiksi, piin tarkka arvo vaatisi äärettömän suuren muistialueen. Sen sijaan suorittimissa käytetään <em>liukulukuja</em>, jotka ovat reaalilukujen kiinteän mittaisia likiarvoja. Liukulukuja on tyypillisesti kahta eri pituutta, 32- ja 64-bittisiä. Esimerkiksi, pii voitaisiin esittää tällöin likiarvona 3.1415927 tai 3.1415926535897931. Kaikissa suorittimissa ei ole edes liukulukuja, koska yksinkertaisissa laitteissa ei ole tarvetta sen tyyppiselle laskennalle.</p><p>Joissakin (vanhemmissa) suorittimissa on tietotyyppi <em>totuusarvo</em> (tosi ja epätosi). Nykyään totuusarvoja käsitellään bitteinä, jolloin tosi on koodattu lukuna 1 ja epätosi lukuna 0. Bittejä käsitellään raakadatan bittioperaatioilla (ks. alla).</p><p>Vanhemmissa suorittimissa saattoi olla myös tietotyypit <em>merkeille</em> ja <em>merkkijonoille</em>. Huonona puolena tässä oli, että koko järjestelmän piti rajoittua johonkin tiettyyn merkkien ja merkkijonojen esitystapaan. Nykyään käytössä on useita eri merkistöjä. Niiden merkit on koodattu kokonaislukujen avulla ja niitä käsitellään kokonaislukuina.</p><p>Kaikki tieto esitetään suorittimella loppujen lopuksi bitteinä, ja suorittimissa on yleensä myös tällainen raakadatan bittiesitysmuoto. Niillä käsitellään tietoa bitteinä riippumatta siitä, mitä nuo bitit tarkoittavat. Joissakin tapauksissa esimerkiksi kokonaislukuja voi olla järkevää käsitellä pelkästään niiden esitysmuodossa bitteinä kuin kokonaislukuina.</p><p>Käsittelemme eri tyyppisten tietojen esitystapoja tarkemmin seuraavassa luvussa.</p><p>Esimerkkitietokoneessa ttk-91 on vain 32-bittisiä kokonaislukuja ja bittiesitysmuodon 32-bittisiä sanoja.</p><h2>Konekäskyt</h2><p>Käskykannassa on kullekin suorittimen ymmärtämälle tietotyypille sen ominaiset perusoperaatiot. Jos samasta tietotyypistä (esim. kokonaisluvut) on olemassa eri pituisia muotoja (esim. 8-, 16-, 32- ja 64-bittiset esitysmuodot), niin tiedon pituus tulee koodata jollain tavoin. Pituus voi olla koodattu omalla operaatiokoodilla tai lisämääreellä. Lisäksi suorittimella on sekalainen joukko konekäskyjä suorittimen yleishallintoon ja käyttöjärjestelmän toimintojen tukemiseen.</p><h3>Aritmetiikkakäskyt</h3><p>Aritmetiikkakäskyissä on mukana aina yhteenlasku, vähennyslasku ja kertolasku. Usein siellä on myös jakolasku, mutta ei aina. Joskus jakolasku toteutetaan kertomalla jaettava jakajan käänteisluvulla, koska se voi olla nopeampaa. Kokonaislukujen jakolaskusta voi tulla talteen myös jakojäännös, mutta usein se pitää kaivaa esiin omalla modulo-konekäskyllä (esim., MOD-käsky).</p><p>Liukuluvuille on omat vastaavat konekäskynsä. Niiden toteutus on jonkin verran monimutkaisempaa kuin kokonaislukujen käsittely ja ne käyttävät yleensä niille varattuja omia liukulukurekistereitä.</p><!-- Koodiesimerkki (ei ttk-91) --><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Esimerkki: yhteenlasku eri tyyppisillä tiedoilla (ei ttk-91)\n\nLaske C=A+B, kun A, B ja C ovat muuttujia muistissa\nsamalla suorittimella. Kustakin muuttujasta on kolme\nversiota. Muuttuja iA on kokonaisluku, fA on\n32-bittinen liukuluku, dA on 64-bittinen liukuluku, jne.\n\nkokon.luvuilla  liukuluvuilla  64-bitt. liukuluvuilla\n\nload  r1,iA      load f1,fA       dload f2,dA\nload  r2,iB      load f2,fB       dload f4,dB\nadd   r3,r1,r2   fadd f3,f1,f2    dfadd f6,f2,f4\nstore r3,iC      store f3,fC      dstore f6,dC</code></pre></div><p>64-bittiset rekisterit muodostetaan usein yhdistämällä kaksi peräkkäistä 32-bittistä rekisteriä. Esimerkin 64-bittiset liukuluvut on talletettu kahteen peräkkäiseen 32-bittiseen liukulukurekisteriin. Muuttujan dA 64-bittinen arvo ladataan rekisteriin f2-f3, jne.</p><p>Ttk-91:ssä on vain kokonaislukujen konekäskyt ADD, SUB, MUL, DIV ja MOD. Siinä ei ole käskyjä liukulukujen käsittelyyn ja sen käskyssä voi nimetä vain kaksi rekisteriä.</p><!-- Note: matem historia, kertolasku, Fibonacci, helmitaulun algoritmi --><text-box variant=\"example\" name=\"Kertolaskun historiaa\"><p>Kertolasku on monimutkaisin operaatio, minkä suoritin pystyy tekemään. Sen monimutkaisuutta ei kannata väheksyä, vaikka olet itse oppinut sen tekemään jo koulussa. Kokonaislukujen kertolasku oli vielä 800 vuotta sitten niin haastavaa, että sen tekemiseen palkattiin ulkopuolinen konsultti. Hänellä oli käytössään useimmiten helmitaulu (abacus) ja siihen sopiva algoritmi. Ongelmana oli, että lukujen esityksessä käytetty menetelmä (esim. roomalaiset numerot) sopi hyvin lukujen tallentamiseen, mutta ei niillä laskemiseen. Konsultti muutti luvut ensin helmitaululle sopivaan muotoon, ratkaisi ongelman ja antoi lopulta asiakkaalle tuloksen hänen ymmärtämässään muodossa.\n<br><br>\nTilanne muuttui radikaalisti 10-järjestelmän keksimisen jälkeen. Fibonacci toi sen vuonna 1202 Eurooppaan kirjassaan Liber abaci. Uusi merkintätapa oli helposti opittavissa ja nyt kuka tahansa saattoi oppia aika yksinkertaiset algoritmit peruslaskutoimituksien tekemiseen noita samoja numeroita käyttäen. Kerta kaikkiaan nerokasta!\n<br><br>\nTilanne on nyt vähän samanlainen kuin 800 vuotta sitten, mutta helmitaulun asemesta käytetään tietokonetta. Asiakkaat antavat konsulttiyritykselle ratkaistavan tehtävän tekstinä. Ohjelmoijat suunnittelevat ongelman ratkaisun tietokoneohjelmaksi. Tietokone suorittaa binäärimuotoisen algoritmin asiakkaan antamia lähtötietoja käyttäen. Lopulta ratkaisu annetaan asiakkaalle tekstinä ja 10-järjestelmän lukuina. Ohjelmoijien ratkaisevat ongelmat ovat nykyään tietenkin aika lailla monimutkaisempia kuin kertolasku. Asiakkaan ei kuitenkaan edelleenkään tarvitse ymmärtää, kuinka ohjelmoija tai tietokone ongelman oikeastaan ratkaisee.</p></text-box><h3>Bittioperaatiot</h3><p>Bittien käsittelyä varten mukana on yleensä ainakin loogiset operaatiot AND, OR, XOR ja NOT. NOT-käskyllä on vain yksi operandi ja se komplementoi jokaisen bitin. Muilla käskyillä on kaksi operandia ja ne tekevät valitun loogisen-operaation pareittain jokaiselle operandien bitille. AND-operaation tulos on 1 (tosi), jos molemmat vastaavat bitit ovat 1, ja muutoin tulos on 0. OR-operaation tulos on 1, jos jompi kumpi tai molemmat operandibiteistä on 1. Muutoin OR-operaation tulos on 0. XOR-operaatio on mielenkiintoisempi. Lyhenne XOR tulee sanasta \"exclusive or\". XOR-operaation tulos on 1, jos jompi kumpi mutta ei molemmat operandibiteistä on 1. Muutoin XOR-tulos on 0. Toisin sanoen, XOR on 1, jos operandit ovat erilaisia.</p><!-- esimerkki bittioperaatioista --><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Esimerkki: bittioperaatiot\n\noperaatio: A and B   A or B   A xor B  not A\nA:          1100      1100     1100    1100\nB:          0101      0101     0101\ntulos:      0100      1101     1001    0011</code></pre></div><p>Bittikäskyt tekevät siis loogiset operaatiot <em>kaikille</em> operandien biteille pareittain. Ne sopivat kuitenkin myös käsittelemään <em>loogisia muuttujia</em>, joissa on vain yksi bitti käytössä. Tällöin esimerkiksi 32-bittisen muuttujan Flag arvo on talletettu vain yhteen bittiin ja loput bitit ovat aina nollia.</p><!-- Note: xor-operaatio salakirjoituksen apuna --><text-box variant=\"example\" name=\"Xor-operaatio salakirjoituksen apuna\"><p>Xor-operaatiota käytetään paljon salakirjoituksessa. Ajatellaan vaikkapa tilannetta, jossa lähetettävänä on salattava viesti APUA, joka käytössä olevan merkkikoodiston (UTF-8) mukaan on bitteinä 01000001_01010000_01010110_01000001. Artolla ja Beritillä on yhdessä sovittu salainen merkkijonoavain 5821, joka on bitteinä  00110011_00111000_00110010_00110001. Arto salakirjoittaa viestin tekemällä operaation APUA xor 5821. Tuloksena on bitit 01110010_01101000_01100100_01110000, mikä vastaa merkkejä rhdp.\n<br><br>\nArto lähettää Beritille salakirjoitetun merkkijonon rhdp, josta kukaan ulkopuolinen ei saa selvää. Berit purkaa salakirjoituksen tekemällä uuden xor-operaation, rhdp xor 5821, jonka tuloksena on bittijono 01000001_01010000_01010110_01000001 eli alkuperäinen viesti APUA. Berit rientää apuun ja Arto on pelastettu!\n<br><br>\nTämä ns. symmetrinen salakirjoitus perustuu xor-operaation ominaisuuteen, jossa kaksi xor-operaatiota samalla operandilla (avaimella 5821) kumoavat toisensa. Tällaista symmetristä salakirjoitusavainta (sama avain Artolla ja Beritillä) käytetään sinunkin pankkiyhteyksien turvaamisessa, mutta vain osana laajempaa järjestelmää.</p></text-box><p>Bittejä käsitellään myös erilaisilla bittien siirtokäskyillä. Niissä yleensä siirretään rekisterissä olevia bittejä vasemmalle (SHL, shift left) tai oikealle (SHR, shift right) haluttu määrä. Siirron yhteydessä bittejä täytetään oikealta tai vasemmalta nollilla. Oikealle tapahtuvan normaalisiirron lisäksi usein on myös SHRA-käsky (shift right arithmetic), jossa nollan asemesta täytetäänkin vasemmalta alkuaan vasemmanpuolimmaista bittiä. Kokonaislukujen esitystavoissa etumerkki on tiedon vasemmanpuolimmainen bitti, joten SHRA-käsky säilyttää kokonaisluvun etumerkin. Tästäkin on hyötyä tietyissä ohjelmointiongelmissa!</p><p>Ttk-91:ssä on bittien siirtokäskyt SHL, SHR ja SHRA.</p><h3>Kontrollin siirtokäskyt</h3><p>Kontrollinsiirtokäskyillä voidaan (ehdollisesti) muuttaa oletusarvoista käskyjen virtaa, jossa seuraavaksi suoritettava käsky on aina edellisen perässä muistissa. Tyypillisesti tällaisia käskyjä ovat ehdottomat <a href=\"https://fi.m.wikipedia.org/wiki/Hyppyk%C3%A4sky\" target=\"_blank\" rel=\"noopener noreferrer\">hyppykäskyt</a> ja ehdolliset haarautumiskäskyt. Ehto voi määräytyä suoraan jonkun rekisterin perusteella vertaamalla sen arvoa nollaan. Esimerkiksi käsky voi olla <em>jneg r1, negat</em>. Se haarautuu osoitteeseen <em>negat</em>, jos rekisterin r1 arvo on negatiivinen. Toisaalta haarautuminen voi perustua aikaisemmin suoritettuun vertailukäskyyn (esim. <em>comp r1, r2</em>), jonka tulos on talletettu tilarekisteriin. Tällainen käsky voisi olla vaikkapa <em>jnles loop</em>. Se haarautuu, jos aikaisemman vertailun tulos oli \"isompi tai yhtäsuuri\" eli \"ei pienempi\".</p><p>Kaikki <a href=\"https://fi.wikipedia.org/wiki/Toistorakenne\" target=\"_blank\" rel=\"noopener noreferrer\">silmukat</a> toteutetaan myös edellä mainituilla ehdottomilla hyppykäskyillä ja ehdollisilla haarautumiskäskyillä. Vaikka korkean tason kielissä on monenlaisia silmukoita (for, while, do-until), niin konekielessä niitä on vain kahta lajia. Silmukan loppumistestaus pitää tehdä joko ennen silmukan runkoa tai sen jälkeen. Silmukka toteutetaan korkean tason kielen semantiikan (merkityksen) mukaiseksi, joten esimerkiksi C-kielessä testi on ennen silmukan runkoa ja Fortranissa rungon jälkeen. Fortran-ohjelmissa silmukan runko suoritetaan aina vähintään yhden kerran.</p><!-- for loop  esimerkki --><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Esimerkki: for-silmukka\n\nFor-loop C-kielen semantiikalla (testi silmukan alussa)\n\nfor (i=0; i&lt;n; i=i+1) {         load   r1, =0     ; r1 on i\n    tbl[i] = 0;            loop comp   r1, n      ; kaikki tehty?\n    }                           jnles  done       ; poistu, jos valmista\n                                load   r2, =0     ; alusta Tbl[i]\n                                store  r2, tbl(r1)\n                                add    r1, =1     ; seuraava i\n                                jump   loop\n                           done ...</code></pre></div><p><a href=\"https://fi.wikipedia.org/wiki/Aliohjelma\" target=\"_blank\" rel=\"noopener noreferrer\">Aliohjelmat</a>, funktiot ja metodit ovat ohjelmoijan perustyökaluja ohjelmoinnissa. Niitä kutsutaan tässä kaikki yleisnimellä \"aliohjelma\". CALL-käskyllä kontrolli siirretään aliohjelmaan, eli se toimii ehdottoman hyppykäskyn tavoin ja aiheuttaa haarautumisen annettuun aliohjelmaan. Haarautumisen lisäksi se muuttaa laskentaympäristön aliohjelman omaan ympäristöön ja tallettaa paluuosoitteen johonkin. Esimerkiksi, aliohjelmassa voi olla omia muuttujia, jotka ovat käytettävissä vain aliohjelman suorituksen aikana. EXIT-käsky suorittaa paluun takaisin kutsun tehneeseen rutiiniin, kutsua seuraavaan konekäskyyn. Se myös palauttaa laskentaympäristön ennalleen.</p><!-- funktion kutsu esimerkki  --><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Esimerkki: funktion kutsu\n\nC-kieli               konekieli\n\nx = sum(y, z);        push  sp, y    ; laita parametrin y arvo pinoon\n                      push  sp, z    ; laita parametrin z arvo pinoon\n                      call  sp, sum  ; kutsu fuktiota Sum\n                      pop   sp, r1   ; ota funktion paluuarvo pinosta\n                      store r1, x    ; talleta paluuarvo muuttujan x arvoksi</code></pre></div><p>Käyttöjärjestelmän palvelupyynnöt (SVC, supervisor call) ovat hyvin samankaltaisia aliohjelmakutsujen kanssa, mutta kuitenkin vähän erilaisia. Suorittimen suoritustila muuttuu etuoikeutetuksi ja kutsun yhteydessä täytyy tarkistaa, onko ohjelmalla oikeus kutsua tätä palvelua vai ei. Palvelusta palataan lopulta omalla paluukäskyllä (esim. IRET, interrupt return).</p><!-- svc kutsu --><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Esimerkki: svc kutsu\n\nC-kieli         konekieli\n\nprint(x);       load  r1, x      ; laita tulostettava arvo rekisteriin r1\n                svc   sp, =print ; kutsu käyttöjärjestelmäpalvelua Print</code></pre></div><p>Ttk-91:ssä on ehdoton hyppykäsky JUMP. Siellä on myös rekisterin nolla-arvoon vertailuun perustuvat haarautumiskäskyt JNEG, JZER, JPOS, JNNEG, JNZER ja JNPOS. Siellä on kahden operandin vertailukäsky COMP tilanteisiin, jossa vertailun kohde on nollasta poikkeava.  Vertailun tulokseen perustuva haarautumiskäskyt ovat JLES, JEQU, JGRE, JNLES, JNEQU ja JNGRE. Nämä haarautumiset vaativat siis aina kahden konekäskyn suorittamisen.</p><p>Ttk-91:ssä on aliohjelmia ja käyttöjärjestelmän palvelupyyntöjä varten CALL, EXIT ja SVC-käskyt. Mitään IRET-käskyä ei ole, koska määrittely ei ole täydellinen. Aliohjelmia ei käsitellä tällä kurssilla tämän enempää.</p><h3>I/O-käskyt</h3><p>I/O-laitteiden käyttö on vaikeata, koska siinä pitää synkronoida toiminta suorittimen ulkopuolisen laitteen kanssa. Yleensä sen tekevät vain käyttöjärjestelmän laiteajurit etuoikeutetussa tilassa. Yksinkertaisille laitteille voi olla omat (etuoikeutetut) konekäskynsä I/O:n tekemiseen. Monimutkaisempien I/O-laitteiden kontrollointia I/O-laitteen oma muisti näkyy keskusmuistin tavoin ohjelman käyttämässä muistiavaruudessa. Laiteajuri voi sitten kirjoittaa sinne dataa ja komentoja sekä lukea laitteen tilatietoa tavallisilla load/store-käskyillä. Emme käsittele I/O:n toteutusta tämän tarkemmin tällä kurssilla.</p><p>Ttk-91:ssä on IN-käsky tiedon lukemiseen näppäimistöltä ja OUT-käsky tiedon kirjoittamiseen näytölle. Näitä voi käyttää tavallisessa suoritustilassa, koska ttk-91:ssä ei muita suoritustiloja ole edes määritelty.</p><p><strong>Syötteen lukeminen käyttäjältä</strong></p><p>Ttk-91:ssä käyttäjän syötteen tulee aina olla kokonaisluku. Konekäskyllä</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">IN R3, =KBD</code></pre></div><p>saadaan luettua tulosrekisteriin rekisteriin R3 käyttäjän syötteenä antama kokonaisluku. Sallittuja rekistereitä IN-käskyn kanssa käytettäessä ovat R0 - R5. Rekisterit R6 (SP) ja R7 (FP) ovat varattu erikoistarkoituksia varten (pino-osoitin ja kehysosoitin).</p><p><strong>Kokonaisluvun tulostaminen</strong></p><p>Ttk-91:ssä tulostaminen näytölle rekisteristä R3 tehdään seuraavasti:</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">OUT R3, =CRT</code></pre></div><p>Rekisteri voi olla R3:n sijasta myös R0 - R7 eli R0 - R5, SP tai FP.</p><!-- IO käsky esimerkki  --><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Esimerkki: I/O-käskyt\n\nC-kieli       konekieli\n\nPrint(x);     load  r1, x    ; laita tulostettava arvo rekisteriin r1\n              out   r1, =crt ; tulosta r1 arvo näytölle konekäskyllä out\n</code></pre></div><h3>Erityiskäskyt</h3><p>Suorittimella on lisäksi sekalainen joukko suorittimen ja järjestelmän hallintaan liittyviä konekäskyjä. Useissa suorittimissa on erikoinen käsky NOP (no operation), mikä ei nimensä mukaisesti tee mitään. Se kuitenkin haetaan käskyjen nouto- ja suoritussyklissä normaalisti, joten se kuluttaa aikaa. Jossain tapauksissa tämä on helpoin tapa rytmittää asioita oikein.</p><p>Suorittimissa voi olla rekisterissä olevien 1-bittien lukumäärän laskemiskäsky, jota tarvitaan joidenkin salakirjoitusjärjestelmien yhteydessä tai niiden murtamiseen. Suorittimissa voi olla (etuoikeutettuja) käskyjä eri välimuistien tyhjentämiseen. Etuoikeutettuja käskyjä on myös kanta- ja rajarekistereiden lukemiseen ja asettamiseen, samoin kuin muidenkin sisäisten muistinhallintarekistereiden käsittelyyn.</p><p>Ttk-91:ssä on NOP-käsky. Siinä ei ole muita erityiskäskyjä, koska määrittely ei ole täydellinen.</p><p>— erityiskäskyesimerkki</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Esimerkki: NOP-käsky\n\nC-kieli           konekieli\n\nif (x&lt;y)                 load r1, x    -- onko x&lt;y?\n  y = x;                 comp r1, y\n                         jnles  jatka  -- ei ole, ohita store\n                         store r1, y\n                  jatka  nop           -- nop-käskyyn voi hypätä</code></pre></div><h3>Symbolisen konekielen kääntäjän ohjauskäskyt, valekäskyt</h3><p>Ohjelmien symbolisen konekielisessä esitystavassa on suorittimen konekäskyjen lisäksi mukana myös kääntäjän ohjauskäskyjä. Niiden avulla ilmaistaan mm. tilanvarauksia muuttujille ja muille tietorakenteille sekä nimiä halutuille vakioarvoille. Näitä kutsutaan joskus myös <em>valekäskyiksi</em>, koska ne näyttävät tavallisilta käskyiltä, mutta niistä ei tule mitään suoritettavaa konekäskyä. Ne vaikuttavat vain ohjelman kääntämisen tai latauksen aikana.</p><h4>Muuttujien, taulukoiden ja vakioiden määrittelyn ohjauskäskyt ttk-91 symbolisessa konekielessä</h4><p><strong>Muuttujan tilanvaraus</strong></p><p>Muuttujan tai vakion tilanvarauskäsky on DC (data constant). Esimerkiksi muuttujan Anna tilanvaraus ja alkuarvon asettaminen tehdään kirjoittamalla ohjelmaan näin:</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Anna DC 200</code></pre></div><p>Käännösvaiheessa kääntäjä varaa muuttujalle <code class=\"language-text\">Anna</code> yhden muistipaikan ohjelman sisäisessä muistiavaruudeta ja asettaa sen muistipaikan arvoksi 200. Käännöksessä kääntäjä käyttää hyväksi <em>symbolien</em> arvoa. Kääntäjä asettaa <em>symbolitauluun</em> symbolin Anna arvoksi muuttujan Anna osoitteen.</p><p><em>Huomaa, että kun käännösvaiheessa puhutaan muistipaikoista, muistiosoitteista ja osoitteista, niillä tarkoitetaan aina ohjelman sisäisen muistiavaruuden osoitteita, jotka alkavat nollasta ja päättyvät ohjelmalle varattuun kokoon vähennettynä yhdellä. Vasta ohjelmaa suorittaessa muistinhallintayksikkö MMU muuntaa ohjelman sisäisen muistiavaruuden osoitteen fyysiseksi keskusmuistiosoitteeksi.</em></p><p>Oletetaan, että muuttujan Anna osoite on 1000 ja ohjelmakoodissa on seuraava konekäsky:</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">LOAD R1, Anna</code></pre></div><p>Tällöin kääntäjä kääntää tämän käskyn ikään kuin se olisi:</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">LOAD R1, 1000</code></pre></div><p><strong>Taulukon tilanvaraus</strong></p><p>Taulukko on tietorakenne, joka koostuu peräkkäisistä muistipaikoista. Taulukon tilanvaraus tehdään tilanvarauskäskyllä DS (data segment). Esimerkiksi tilanvaraus taulukolle <code class=\"language-text\">Arvosanat</code> saadaan tehtyä seuraavasti.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Arvosanat DS 30</code></pre></div><p>Tällöin kääntäjä varaa taulukolle 30 peräkkäistä muistipaikkaa ja asettaa symbolin <code class=\"language-text\">Arvosanat</code> arvoksi taulukon ensimmäisen osoitteen.</p><p>Oletetaan, että tuo alkuosoite on 1001 ja että ohjelmakoodissa on seuraava käsky:</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">STORE R1, Arvosanat(R3)</code></pre></div><p>Tällöin kääntäjä kääntää sen kuin ohjelmakoodissa olisi lukenut:</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">STORE R1, 1001(R3)</code></pre></div><p>Koska ttk-91:ssä on käytössä <em>indeksoitu muistiinosoitus</em>, tuo konekäsky tallentaa rekisterin R1 arvon osoitteeseen, joka saadaan laskemalla 1001 + R3 eli 1001 + rekisterin R3 arvo. Jos rekisterin R3 arvo on ennen tuon käskyn suorittamista 20, niin tällöin tuo konekäsky tallentaa rekisterin R1 arvon osoitteeseen 1001+20\\ = 1021.</p><p><strong>Symbolin arvon määrittäminen</strong></p><p>Joskus on kätevää määritellä ohjelmoidessa joitakin vakioita, jotka kuitenkin muunnetaan jo käännösvaiheessa kokonaisluvuiksi. Tätä varten ttk-91-kääntäjässä on käytössä ohjauskäsky <code class=\"language-text\">EQU</code>. Sitä käytetään seuraavasti ohjelmakoodissa:</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">VASTAUS EQU 42</code></pre></div><p>Tällöin kääntäjä asettaa symbolitauluun symbolin <code class=\"language-text\">VASTAUS</code> arvoksi 42. Oletetaan, että ohjelmassa on lisäksi tällainen rivi:</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">COMP R2, =VASTAUS</code></pre></div><p>Tällöin kääntäjä kääntää kyseisen konekäskyn ikään kuin siinä olisi lukenut seuraavasti:</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">COMP R2, =42</code></pre></div><!-- ttk91 ohjelmaesimerkki --><h4>Ttk-91 ohjelmaesimerkki</h4><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ttk-91 ohjelmaesimerkki\n\nLaske taulukon tbl alkioiden arvojen summa muuttujan sum arvoksi. Tulosta\nmuuttujan sum arvo.\n\n                   -- tilanvaraukset\nsum    dc    0        -- määr. ja varaa tilaa muuttujalle sum, alkuarvo 0\n                      -- symbolin sum arvo on muuttujan sum osoite\ntbl    ds   20        -- määrittele ja varaa tilaa 20-alkioiselle\n                      -- taulukolle tbl.\n                      -- symbolin tbl arvo on taulukon ensimmäisen\n                      -- alkion tbl[0] osoite\nlkm    equ  20        -- määrittele symboli lkm, jolla arvo 20\n\nstart  ...            -- aloita ohjelman suoritus\n       ...            -- alusta taulukko tbl jollain tavalla\n\n                      -- alusta summan laskeminen\n      load r3, =lkm      -- r3=raja-arvo, aseta arvo  (välitön tied.os.)\n      load r2, =0        -- r2=indeksi i, alkuarvo 0  (välitön tied.os.)\n      load r1, =0        -- r1=summa, alkuarvo 0      (välitön tied.os.)\n                      -- vertaa ja laske summaa\nloop  comp r2, r3        -- vertailun tulos tilarekisteriin (väl. tied.os.)\n      jeq done           -- poistu silmukasta lopuksi       (väl. tied.os.)\n      add r1, tbl(r2)    -- lisää tbl[i] summaan           (suora muistiv.)\n                      -- seuraava alkio\n      add r2, =1         -- lisää indeksiin r2 luku 1   (välitön tiedonos.)\n      jump loop          -- palaa testaamaan            (välitön tiedonos.)\n                      -- tallenna ja tulosta summa\ndone  store r1, sum      -- tallenna summa muuttujaan sum  (suora muistiv.)\n      load  r4, sum      -- lue r4:ään muuttujan sum arvo  (suora muistiv.)\n      out   r4, =crt     -- tulosta r4:n arvo näytölle   (välitön tied.os.)\n                      -- lopeta ohjelman suoritus\n      svc   sp, =halt    -- kutsu käyttöjärj.palv. 11    (välitön tied.os.)</code></pre></div><!-- Note: Ttk-91 simulaattori Titokone  -- onko OK laittaa näkyville? Entä TitoTrainer?  --><text-box variant=\"example\" name=\"Titokone\"><p><a href=\"https://www.cs.helsinki.fi/group/titokone/\" target=\"_blank\" rel=\"noopener noreferrer\">Titokone</a> on kevällä 2004 Helsingin yliopistossa opiskelijoiden harjoitustyönä toteuttama ohjelmisto, jonka avulla voidaan kääntää ja suorittaa symbolisella konekielellä kirjoitettuja ohjelmia Auvo Häkkisen vuonna 1991 opetuskäyttöä varten määrittelemälle ttk-91 tietokoneelle. Titokone-ohjelmistoon sisältyy symbolisen konekielisen ohjelmoinnin ohjelmistonkehitysympäristö sekä suorituksen simulaattori ja animaattori.\n<br><br>\nTitokone löytyy verkkosivulta <a href=\"https://www.cs.helsinki.fi/group/titokone/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cs.helsinki.fi/group/titokone/</a>. Helpoin tapa ajaa Titokonetta on tallettaa verkkosivulta löytyvä jar-tiedosto (<a href=\"https://www.cs.helsinki.fi/group/titokone/distr/titokone-1.203.jar\" target=\"_blank\" rel=\"noopener noreferrer\">titokone-1.203.jar</a>) omalle koneellesi ja avata se. Verkkosivulta löytyy myös Titokoneen käyttöohjeet. Valmiita esimerkkejä ttk-91 symbolisen konekielen ohjelmista löytyy verkkosivulta <a href=\"http://www.cs.helsinki.fi/group/nodes/kurssit/tito/esimerkit\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.cs.helsinki.fi/group/nodes/kurssit/tito/esimerkit</a>.\n<br><br>\nTällä kurssilla ei mitenkään edellytetä konekielisen ohjelmoinnin harjoittelua Titokoneella. Se voi kuitenkin olla hauskaa, kuten kaikki muukin ohjelmointi. Malta kuitenkin jatkaa kurssin läpikäyntiä, äläkä jää huvittelemaan Titokoneen kanssa.</p><p>Kurssilla Tietokoneen toiminnan jatkokurssi 2022 tutustutaan tarkemmin ttk-91-ohjelmointiin ja TitoTrainer-oppimisympäristössä tehdyt ohjelmointitehtävät ovat osa kurssisuoritusta. Voit halutessasi jo harjoitella ohjelmointia ja suorittamasi tehtävät huomioidaan tuolla jatkokurssilla.</p><p>TitoTraineriä käytetään osoitteessa <a href=\"http://titotrainer2.users.cs.helsinki.fi/\" target=\"_blank\" rel=\"noopener noreferrer\">http://titotrainer2.users.cs.helsinki.fi/</a>. Voit luoda sinne oman tunnuksen ja valita kurssiksi MOOC 2022. Valitse mahdollisimman yksilöllinen tunnus, sillä jos jokin tunnus on jo aiemmin olemassa, TitoTrainer ei välttämättä kerro sitä, vaan ilmoittaa jostakin muusta virheestä.</p></text-box><!-- quiz 2.3.1-9 Konekäsky- ja bittitehtäviä --><div><quiz id=\"147ae495-671a-5860-b4a3-325b4de3d516\"></quiz></div>\n<div><quiz id=\"c755c8de-24b9-5af4-b242-3e18aaf648f5\"></quiz></div>\n<div><quiz id=\"5cf3ff62-21c5-5ba4-950b-dba748cd8570\"></quiz></div>\n<div><quiz id=\"bdf43b38-a75b-579f-b456-d0e9eff1262a\"></quiz></div>\n<div><quiz id=\"7e6d4434-ba27-558d-b776-62b76c9d5eb7\"></quiz></div>\n<div><quiz id=\"27ba6814-1c57-572e-b0cf-fd0b9100570d\"></quiz></div>\n<div><quiz id=\"786d8194-beb1-55e7-ba0b-89f9e8ff3db4\"></quiz></div>\n<div><quiz id=\"2f8ab620-b418-5fad-bd06-3f4f6bfdbecb\"></quiz></div>\n<div><quiz id=\"3c9acabf-b3d3-5a3d-a395-aac1295770ba\"></quiz></div></div>","frontmatter":{"path":"/luku-2/3-konekaskyt","title":"Konekäskyt"}},"allPages":{"edges":[{"node":{"id":"f84c69b8-0195-598e-b051-638a517adb15","frontmatter":{"path":"/arvostelu-ja-kokeet","title":"Arvostelu ja kokeet"}}},{"node":{"id":"97559a5f-7228-505c-a45a-e0873044f86b","frontmatter":{"path":"/credits","title":"Tekijänoikeudet ja lisenssit"}}},{"node":{"id":"b5e3212a-e9e7-5514-87e6-07e3f18fee95","frontmatter":{"path":"/opettajille","title":"Opettajille ja opinto-ohjaajille"}}},{"node":{"id":"a0c4823b-46b6-5707-beb2-8a229b5a2beb","frontmatter":{"path":"/osaamistavoitteet","title":"Osaamistavoitteet"}}},{"node":{"id":"dbb6d14b-2dea-5f9a-85fc-30eb59a77a70","frontmatter":{"path":"/","title":""}}},{"node":{"id":"a0c06bb0-616a-594f-b31a-cf57faa3a1ed","frontmatter":{"path":"/tukivaylat","title":"Tukiväylät"}}},{"node":{"id":"ea6e5cfa-14c1-53b5-99da-25b985ab3a7b","frontmatter":{"path":"/usein-kysytyt-kysymykset","title":"Palaute ja usein kysytyt kysymykset"}}},{"node":{"id":"cafd05e1-5355-5bf8-a41c-b955593fd3fd","frontmatter":{"path":"/luku-1/1-mika-on-tietokone","title":"Tietokone"}}},{"node":{"id":"d9390807-bada-58ad-a2b0-59515c977a08","frontmatter":{"path":"/luku-1/2-ohjelma","title":"Ohjelma"}}},{"node":{"id":"7c078337-dddc-5acf-ab5e-7ade2e1444c5","frontmatter":{"path":"/luku-1/3-laitteiston-nopeuserot","title":"Laitteiston nopeuserot"}}},{"node":{"id":"03eacc49-4552-5b0b-bd14-e18ee30fea39","frontmatter":{"path":"/luku-1","title":"Luku 1: Tietokonejärjestelmä ja ohjelma?"}}},{"node":{"id":"8fd68708-1f3b-5ded-857f-4ff583ebe0a2","frontmatter":{"path":"/luku-2/1-suorittimen-rakenne","title":"Suorittimen rakenne"}}},{"node":{"id":"25190d7c-3ec2-5d92-bc9b-a9eaea77075b","frontmatter":{"path":"/luku-2/2-suoritussykli","title":"Käskyjen nouto- ja suoritussykli"}}},{"node":{"id":"a23135b2-b131-59cd-b1c6-cfefd4c12714","frontmatter":{"path":"/luku-2/3-konekaskyt","title":"Konekäskyt"}}},{"node":{"id":"c9b57a30-4ec9-53c6-ba7e-6e2d020edf88","frontmatter":{"path":"/luku-2/4-tiedon-sijainti","title":"Tiedon sijainti suoritusaikana"}}},{"node":{"id":"bb32b4c9-f268-5ee0-ab30-2c8015858045","frontmatter":{"path":"/luku-2","title":"Luku 2: Suoritin ja muisti"}}},{"node":{"id":"0363ae7c-d894-551b-b701-4d6154421c91","frontmatter":{"path":"/luku-3/1-tiedon-kategoriat","title":"Tiedon kategoriat, binääri- ja heksadesimaalijärjestelmät, monitavuisen tiedon tallennus"}}},{"node":{"id":"b4f1ad3e-ddda-5fe0-81b4-1d3cd70451ca","frontmatter":{"path":"/luku-3/2-kokonaisluvut-ja-liukuluvut","title":"Kokonaislukujen ja liukulukujen esitysmuodot"}}},{"node":{"id":"90801e3d-d0e8-5485-86f5-8e0192f5535e","frontmatter":{"path":"/luku-3/3-taulukot-tietueet","title":"Taulukot, tietueet ja muu rakenteinen tieto"}}},{"node":{"id":"6dddcd21-639d-504f-88cc-db830c98f75c","frontmatter":{"path":"/luku-3/4-merkit-etc","title":"Merkit, kuvat ja tunteenpalo"}}},{"node":{"id":"f778c926-0e93-5b7a-9b50-5fd503f42528","frontmatter":{"path":"/luku-3","title":"Luku 3: Tiedon esitysmuodot"}}},{"node":{"id":"3d13f5ae-50f5-5454-a662-9bf3e2bde459","frontmatter":{"path":"/luku-4/1-kayttojarjestelman-tehtavat","title":"Käyttöjärjestelmän tehtävät"}}},{"node":{"id":"3187dc8f-8296-53a6-b73a-9880d556ae9b","frontmatter":{"path":"/luku-4/2-prosessi","title":"Prosessi"}}},{"node":{"id":"b74906bf-020f-526d-a4a0-d079accbb347","frontmatter":{"path":"/luku-4/3-kayttojarjestelman-toteutus","title":"Käyttöjärjestelmän toteutus"}}},{"node":{"id":"7c3125f9-4d7c-52fe-83e1-bf564067c597","frontmatter":{"path":"/luku-4/4-laskentakyvyn-rajat","title":"Tietokoneen laskentakyvyn rajat"}}},{"node":{"id":"20ffd10f-ce80-5f7e-9c31-cf0bc2bb2edd","frontmatter":{"path":"/luku-4","title":"Luku 4: Käyttöjärjestelmä ja laskentakyvyn rajat"}}}]}},"pageContext":{}},
    "staticQueryHashes": ["2283872788","994120085"]}