{
    "componentChunkName": "component---src-templates-course-content-template-js",
    "path": "/luku-2/4-tiedon-sijainti",
    "result": {"data":{"page":{"htmlAst":{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"lead","properties":{},"children":[{"type":"text","value":"\nTässä osiossa tarkastelemme tiedon eri sijaintipaikkoja suoritusaikana. Tiedon sijainnilla on huomattava merkitys ohjelman suoritusnopeuteen.\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Tiedon sijaintipaikat"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ohjelman suoritusaikana viittaama tieto voi sijaita kolmessa eri paikassa. Ensinnäkin, se voi sijaita suorittimen rekisterissä. Tuolloin se voi olla joko konekäskyssä nimetty rekisteri (esim. R3), joku oletusarvoinen sisäinen rekisteri (esim. PC tai SR) tai käskyrekisterin (IR) joku kenttä (esim. vakiokenttä tai operaatiokoodi). Käskyrekisterin kentät ovat hyvin helposti saatavilla suorittimella ja niiden lukeminen on ainakin yhtä nopeata kuin konekäskyssä viitattavien rekistereiden viittaukset. Rekistereitä on korkeintaan muutama kymmen, joten kovin moni tieto ei sinne mahdu. Lisäksi rekistereihin mahtuu vain ns. skalaarimuotoinen tieto, mikä tarkoittaa yksinkertaista korkeintaan yhden tai kahden sanan mittaista tietoa. Esimerkkejä ovat eri kokoiset kokonaisluvut ja liukuluvut. Rekistereihin ei voi tallettaa esimerkiksi 1000-alkioista taulukkoa, vaan sen alkiot pitää käsitellä rekisterissä yksi kerrallaan. On tosin erikoistapauksia, joissa esim. 64 alkioisiin "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"vektorirekistereihin"}]},{"type":"text","value":" voi tallettaa usean data-alkion, joita kaikkia pystyy operoimaan yhdellä kertaa "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"vektorikäskyillä"}]},{"type":"text","value":". Emme käsittele tällaisia "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"vektorisuorittimia"}]},{"type":"text","value":" tällä kurssilla."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Toiseksi, tieto voi olla välimuistissa. Välimuisteja voi olla useita tasoja, joista suoritinta lähempänä olevat ovat pienempiä ja nopeampia. Välimuisteja voi olla erikseen koodille ja datalle, koska näin niistä voi saada tehokkaampia. Tällöin konekäskyt haetaan omasta "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"käskyvälimuistista"}]},{"type":"text","value":" ja normaalit dataviitteet koetetaan löytää "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"datavälimuistista"}]},{"type":"text","value":". Välimuistien toimintalogiikka on täysin automaattista, eikä siihen voi mitenkään vaikuttaa suoritusaikana."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Kolmanneksi, tieto voi olla muistissa. Kaikki tieto mahtuu tänne, mutta välttämättä kaikki ohjelman tarvitsema tieto ei silti ole aina paikalla. Pääosa ohjelman käyttämästä tiedosta on muistissa, josta se haetaan tarvittaessa rekistereihin ja välimuistiin. Usein välimuistiin haetaan tietoa myös spekulatiivisesti arvaamalla, että kohta tuotakin tietoa varmaan käytetään. Esimerkiksi, kun viittaat taulukon ensimmäiseen alkioon, niin siinä yhteydessä välimuistiin voidaan hakea saman taulukon toinen, kolmas ja neljäskin alkio."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Suoritusaikainen tieto ei voi olla massamuistissa, koska tiedon hakemiseen sieltä kuluu liikaa aikaa. Jos ohjelma haluaa viitata massamuistissa olevaan tietoon, ohjelman suoritus keskeytetään ja tarvittava tieto kopioidaan muistiin. Tämän jälkeen suoritus voi jatkua, mutta nyt viitattu tieto löytyykin muistista. Tiedon siirron aikana suoritin suorittaa muita ohjelmia."}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Eri paikoissa olevaan tietoon viittaaminen"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Suorittimen normaalissa rekisterissä olevaan tietoon viitataan konekäskyissä nimeämällä kyseinen rekisteri. Samoin käskyrekisterissä (IR) olevaan vakioon tai osoitteeseen viittaaminen on nopeata, koska tieto on jo valmiiksi suorittimella. Sama pätee paikanlaskuriin (PC) viittaamiseen. Molemmat rekisterit löytyvät suorittimen kontrolliyksiköstä ja IR:n eri kentät ovat siellä valmiiksi eroteltu lukemista varten. PC:n arvoa pitää joissakin konekielissä pystyä lukemaan myös konekäskyn suorituksen aikana, koska hyppy- tai haarautumiskäskyn osoite olla määriteltynä suhteellisena osoitteena PC:n suhteen. Nämä ovat nopeimmat tavat viitata tietoon."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Välimuistissa olevaan tietoon ei voi suoraan viitata, koska suoritusaikana ei voi tietää, löytyykö tieto välimuistista vai ei. Muistissa olevaan tietoon viitatessa aina tarkistetaan ensin, josko tieto löytyisikin välimuistista. Jos se löytyy, niin hyvä niin ja tieto on nopeasti saatavilla. Ohjelmakoodissa voi lisätä todennäköisyyttä tiedon löytymiseen välimuistista, jos koodin kirjoittaja ymmärtää välimuistin toimintatapaa. Välimuistit pyrkivät pitämään saatavilla viime aikoina viitattuja ja niiden lähellä olevia muistialueita. Hyvä koodaaja pystyy hyödyntämään tätä tietoa ohjelman toiminnan nopeuttamiseksi."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Muistissa olevaan tietoon viitataan käyttäen suorittimen ymmärtämiä muistinosoitusmuotoja, joista suora (indeksoitu) muistiviite on yleisimmin käytetty. Epäsuoria muistiviitteitä ei nykyään useinkaan enää käytetä, koska niiden suoritus kestää niin kauan aikaa. Sen sijaan epäsuorat muistiviitteet toteutetaan yleensä kahdella suoraa muistinosoitusta käyttävällä konekäskyllä, joista ensimmäinen hakee tiedon osoitteen muistista ja toinen sitten käyttää tätä osoitetta tiedon lukemiseen tai kirjoittamiseen. On helpompi toteuttaa nopeita suorittimia, jos kaikkien konekäskyjen (ja niiden osien) suoritus kestää yhtä kauan."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Tiedon sijainti ja siihen osoittaminen\nHuom: nämä ovat irrallisia käskyjä - ne eivät muodosta ohjelmaa.\nKaikkien käskyjen tulos talletetaan rekisteriin r2.\n\nptrX dc 453828           -- symbolin ptrX arvo on (osoitin)muuttujan ptrX\n                            osoite. (Osoitin)muuttujan ptrX arvo on\n                            muistissa olevan tiedon osoite\nTbl  ds 200              -- symbolin Tbl arvo on 200-alkioisen taulukon\n                            ensimmäisen alkion osoite\n\n    load  r2, =80        -- luku 80 on IR:n vakio-osassa\n    load  r2, Tbl(r1)    -- Tbl(r1) on suora muistinosoitusviite\n                            keskusmuistiin, osoitteeseen 280. Arvo 280 on\n                            lukujen 200 (IR:n vakio-osa) ja 80 (rek r1)\n                            summa. Tulos talletetaan r2:een.\n    add   r2, =1         -- ensimmäinen operandi on r2:ssä\n                            toinen operandi (luku 1) on IR:n vakio-osassa.\n    load  r2, Tbl(r5)    -- alkio Tbl(r5) osoitteesta 281 löytyisi\n                            luultavasti välimuistista, koska sen viereiseen\n                            alkioon osoitteessa 280 viitattiin juuri äsken.\n    load  r2, @ptrX      -- epäsuora muistiviite, ptrX arvo löytyy IR:n\n                            vakio-osasta, tiedon osoite 453828 löytyy\n                            muistista (osoitteesta ptrX), tieto löytyy\n                            muistista ptrX:n osoittamasta osoitteesta 453828"}]}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Tiedon sijainnin vaikutus suoritusnopeuteen"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Yleisesti ottaen kaikki tieto sijaitsee muistissa ja juuri nyt käsiteltävänä oleva tieto sijaitsee suorittimen rekistereissä. Tästä on se seuraus, että jokin tietty tieto (esim. muuttujan X arvo) voi sijaita sekä muistissa että rekisterissä. On ohjelmoijan vastuulla, että X:n arvon muuttuessa se tarvittaessa talletetaan myös muistiin. Muistissa sijaitseva tieto voi olla myös välimuistissa, mutta laitteisto huolehtii automaattisesti sen kirjoittamisesta muistiin tarvittaessa."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Korkean tason kieliä käytettäessä kääntäjä päättää, milloin jokin tieto pidetään missäkin rekisterissä. Se on itse asiassa hyvin vaikea ns. "},{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Register_allocation","target":"_blank","rel":["noopener","noreferrer"]},"children":[{"type":"text","value":"rekistereiden allokointiongelma"}]},{"type":"text","value":", koska rekistereitä on hyvin vähän ja kuitenkin kaikki laskenta tapahtuu rekistereissä olevan tiedon varassa."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Esimerkiksi, kaikkialla näkyvän laskuri Count ja sen yläraja Limit olisi hyvä pitää rekistereissä silmukan koko suoritusajan, jos niihin viitataan vähän väliä. Jos ohjelman suorituksessa on sitten pitkä tauko, jolloin Count'iin tai Limit'iin ei tule lainkaan viittauksia, niin silloin niiden arvoja ei kannata pitää rekisterissä. Ohjelmakoodissa tiedon sijainti näkyy siinä, että viitataanko suoraan rekisteriin vai haetaanko tieto ensin johonkin rekisteriin muistista."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Esimerkki: Count ja Limit rekistereissä r1 ja r2\n\n    add   r1, =1       -- kasvata muuntelumuuttujaa Count\n    comp  r1, r2       -- testaa loopin loppuminen, Count vs. Limit?\n    jless loop         -- hyppää, jos Count < Limit"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Toisaalta, ei ole itsestään selvää, että muuttujien Count ja Limit arvot kannattaisi pitää rekistereissä juuri tämän silmukan suorituksen aikana. Rekistereitä on vähän ja niille voisi olla vielä tärkeämpääkin käyttöä. Niiden arvot voisi yhtä hyvin pitää muistissa. Koodista tulee (tältä osin) hitaampaa, koska suoritettavia käskyjä on enemmän ja ne viittaavat muistiin useammin."}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Esimerkki: Count ja Limit molemmat muistissa\n\n    load  r4, Count    -- lisää muuntelumuuttujaa\n    add   r4, =1\n    store r4, Count\n    load  r3, Count    -- testaa loopin loppuminen\n    comp  r3, Limit\n    jless loop"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Kolmaskin vaihtoehto on olemassa. Silmukan muuntelumuuttujan arvon voi pitää rekisterissä silmukan suoritusajan ja sitten lopuksi tallettaa muistiin. Esimerkiksi C-kielessä muuntelumuuttujat ovat tavallisia muuttujia ja niiden loppuarvon täytyy olla käytettävissä myös silmukan jälkeen. Joissakin toisissa kielissä muuntelumuuttujan arvoa ei ole määritelty silmukan päättyessä tai muuntelumuuttujaa ei ole edes määritelty silmukan ulkopuolella. Korkean tason ohjelmointikieliä on hyvin erilaisia ja niillä on merkittäviä mielenkiintoisia eroavaisuuksia!"}]},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Esimerkki: muuntelumuuttuja rekisterissä ja muistissa\n\n      load  r1, =0    -- alusta muuntelumuuttuja i (r1:ssä)\n\nloop  comp  r1, =50   -- testaa loopin loppuminen\n      jnles done\n\n      ...             -- for-silmukan runko (itse asia) tässä\n      ...\n\n      add   r1, =1    -- i:n lisäys ja paluu silmukkaan\n      jump  loop\n\ndone  store  r1, i    -- talleta i:n loppuarvo (koska ohjelmointikielen\n                         semantiikka sitä vaatii)"}]}]}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"On siis tapauksia, joissa ohjelmassa nimetty tieto ei sijaitse missään tällä hetkellä. Edellä mainitun silmukan muuntelumuuttujan lisäksi tällaisia tietoja ovat aliohjelmien paikalliset muuttujat ja muut tietorakenteet, jotka varataan muistista vasta aliohjelmaa kutsuttaessa ja vapautetaan muistista aliohjelmasta poistuttaessa."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Käskyrekisterin (IR) kautta jotain vakioarvoa käytettäessä kääntäjällä (koodin kirjoittajalla) on kaksi mahdollisuutta. Käskyrekisteriin voidaan laittaa itse vakio (esim. arvo 1000), joka sitten replikoidaan jokaiseen tuota tietoa käyttävään konekäskyyn. Toinen vaihtoehto on tallettaa vakio muistiin ja laittaa jokaiseen siihen viittaaviin konekäskyyn vakion osoite muistissa. Molemmilla lähestymistavoilla on etunsa ja haittansa. Konekäskyssä oleva vakiolla voi olla koko- tai tyyppirajoitus, mutta sen käyttö on nopeata. Muistissa olevaan vakioon on hitaampi viitata, mutta sitä voi tarvittaessa kuitenkin muokata."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Välimuistin käyttö on tuuripeliä, mutta siihen voi vaikuttaa. On aina tehokkaampaa käydä läpi mitä tahansa suurempaa tietomassaa samassa järjestyksessä kuin se on talletettu muistiin. Ohjelmakoodin tasolla tämä tarkoittaa hyppyjen ja haarautumisten välttämistä, mikä ei käytännössä ole lainkaan helppoa. Koodissa viitatun datan osalta se tarkoittaa, että esimerkiksi 2-ulotteisia taulukoita voi olla parempi käydä läpi riveittäin kuin sarakettain. Usein ohjelmalogiikka valitettavasti vaatii tiedon läpikäyntiä välimuistin kannalta \"tehottomassa\" järjestyksessä. Aina ei voi voittaa!"}]},{"type":"comment","value":" Quiz 2.4.1-10 Väitteet tiedon sijainnin vaikutuksesta suoritusnopeuteen "},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"8f488186-0578-5cc4-bf46-a77fe54af7af"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"dc21b029-65d6-5322-8e05-df303023edae"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"f6956e5d-0428-53b2-bdaf-2c812a81b6ce"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"6b4bcf9a-245c-57e4-ab80-81b58fe170f7"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"7c53d5ad-94c6-5cbc-af8d-9833f96a42ac"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"cdd04b1e-f14f-5232-a8aa-e58237fb4e1e"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"1cd5d5c2-f658-578d-a037-4842b560ff7e"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"5e7457a6-4dcb-5ec8-a9c5-c8effb937c9d"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"1176fc2f-5b57-5d31-9d0b-5885aebd88a0"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"be782d06-a745-56f7-aac2-351904fd5ba1"},"children":[]}]},{"type":"element","tagName":"text-box","properties":{"variant":"example","name":"Historiaa:  ESKO"},"children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ESKO eli Elektroninen SarjaKOmputaattori (1960) oli ensimmäinen Suomessa rakennettu tietokone. Se oli vanhentunut jo valmistuessaan ja suoritti noin 20 yhteenlaskua sekunnissa. Ohjelmakoodi luettiin reikänauhoilta. Aliohjelmaa kutsuttiin siirtämällä kontrolli sitä vastaavaan reikänauhan lukijaan, jossa aliohjelman koodi oli reikänauhalla ikuisessa silmukassa. Muistina oli 1840 sanan rumpumuisti. ESKOn varsinainen arvo oli tuoda tietotekniikan osaamista Suomeen."}]},{"type":"comment","value":" kuva: ch-2-4-esko    "},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/544abd152e535061bc4370765d71aa03/ch-2-4-esko.svg","alt":"Kaksi valokuvaa. Vasemmalla ESKO kokonaisuudessaan ja sen edessä muistina toimiva rumpumuisti ja reikänauhan lukijat. Oikealla on lähikuva reikänauhan lukijoista."},"children":[]}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"illustrations","properties":{"motive":"ch-2-4-esko"},"children":[]},{"type":"text","value":"\n"}]}]},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Yhteenveto"}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Toinen luku käsitteli suorittimen ja muistin toimintaa. Aluksi katsoimme vähän tarkemmin suorittimen rakennetta ja erityisesti sen toimintaa käskyjen nouto- ja suoritussyklin toteuttajana. Sen jälkeen tarkastelimme konekäskyjen eri tyyppejä ja rakennetta. Lopuksi katsoimme, kuinka tiedon sijainti suoritusaikana voi vaihdella ja kuinka se vaikuttaa ohjelmien suoritusnopeuteen."}]},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Vastaa alla olevaan kyselyyn, kun olet valmis tämän luvun tehtävien kanssa."}]},{"type":"element","tagName":"div","properties":{},"children":[{"type":"element","tagName":"quiz","properties":{"id":"cf78e5e2-6922-503c-a07b-783cec690d86"},"children":[]}]}]},"html":"<div><div><lead>\nTässä osiossa tarkastelemme tiedon eri sijaintipaikkoja suoritusaikana. Tiedon sijainnilla on huomattava merkitys ohjelman suoritusnopeuteen.\n</lead></div><h2>Tiedon sijaintipaikat</h2><p>Ohjelman suoritusaikana viittaama tieto voi sijaita kolmessa eri paikassa. Ensinnäkin, se voi sijaita suorittimen rekisterissä. Tuolloin se voi olla joko konekäskyssä nimetty rekisteri (esim. R3), joku oletusarvoinen sisäinen rekisteri (esim. PC tai SR) tai käskyrekisterin (IR) joku kenttä (esim. vakiokenttä tai operaatiokoodi). Käskyrekisterin kentät ovat hyvin helposti saatavilla suorittimella ja niiden lukeminen on ainakin yhtä nopeata kuin konekäskyssä viitattavien rekistereiden viittaukset. Rekistereitä on korkeintaan muutama kymmen, joten kovin moni tieto ei sinne mahdu. Lisäksi rekistereihin mahtuu vain ns. skalaarimuotoinen tieto, mikä tarkoittaa yksinkertaista korkeintaan yhden tai kahden sanan mittaista tietoa. Esimerkkejä ovat eri kokoiset kokonaisluvut ja liukuluvut. Rekistereihin ei voi tallettaa esimerkiksi 1000-alkioista taulukkoa, vaan sen alkiot pitää käsitellä rekisterissä yksi kerrallaan. On tosin erikoistapauksia, joissa esim. 64 alkioisiin <em>vektorirekistereihin</em> voi tallettaa usean data-alkion, joita kaikkia pystyy operoimaan yhdellä kertaa <em>vektorikäskyillä</em>. Emme käsittele tällaisia <em>vektorisuorittimia</em> tällä kurssilla.</p><p>Toiseksi, tieto voi olla välimuistissa. Välimuisteja voi olla useita tasoja, joista suoritinta lähempänä olevat ovat pienempiä ja nopeampia. Välimuisteja voi olla erikseen koodille ja datalle, koska näin niistä voi saada tehokkaampia. Tällöin konekäskyt haetaan omasta <em>käskyvälimuistista</em> ja normaalit dataviitteet koetetaan löytää <em>datavälimuistista</em>. Välimuistien toimintalogiikka on täysin automaattista, eikä siihen voi mitenkään vaikuttaa suoritusaikana.</p><p>Kolmanneksi, tieto voi olla muistissa. Kaikki tieto mahtuu tänne, mutta välttämättä kaikki ohjelman tarvitsema tieto ei silti ole aina paikalla. Pääosa ohjelman käyttämästä tiedosta on muistissa, josta se haetaan tarvittaessa rekistereihin ja välimuistiin. Usein välimuistiin haetaan tietoa myös spekulatiivisesti arvaamalla, että kohta tuotakin tietoa varmaan käytetään. Esimerkiksi, kun viittaat taulukon ensimmäiseen alkioon, niin siinä yhteydessä välimuistiin voidaan hakea saman taulukon toinen, kolmas ja neljäskin alkio.</p><p>Suoritusaikainen tieto ei voi olla massamuistissa, koska tiedon hakemiseen sieltä kuluu liikaa aikaa. Jos ohjelma haluaa viitata massamuistissa olevaan tietoon, ohjelman suoritus keskeytetään ja tarvittava tieto kopioidaan muistiin. Tämän jälkeen suoritus voi jatkua, mutta nyt viitattu tieto löytyykin muistista. Tiedon siirron aikana suoritin suorittaa muita ohjelmia.</p><h2>Eri paikoissa olevaan tietoon viittaaminen</h2><p>Suorittimen normaalissa rekisterissä olevaan tietoon viitataan konekäskyissä nimeämällä kyseinen rekisteri. Samoin käskyrekisterissä (IR) olevaan vakioon tai osoitteeseen viittaaminen on nopeata, koska tieto on jo valmiiksi suorittimella. Sama pätee paikanlaskuriin (PC) viittaamiseen. Molemmat rekisterit löytyvät suorittimen kontrolliyksiköstä ja IR:n eri kentät ovat siellä valmiiksi eroteltu lukemista varten. PC:n arvoa pitää joissakin konekielissä pystyä lukemaan myös konekäskyn suorituksen aikana, koska hyppy- tai haarautumiskäskyn osoite olla määriteltynä suhteellisena osoitteena PC:n suhteen. Nämä ovat nopeimmat tavat viitata tietoon.</p><p>Välimuistissa olevaan tietoon ei voi suoraan viitata, koska suoritusaikana ei voi tietää, löytyykö tieto välimuistista vai ei. Muistissa olevaan tietoon viitatessa aina tarkistetaan ensin, josko tieto löytyisikin välimuistista. Jos se löytyy, niin hyvä niin ja tieto on nopeasti saatavilla. Ohjelmakoodissa voi lisätä todennäköisyyttä tiedon löytymiseen välimuistista, jos koodin kirjoittaja ymmärtää välimuistin toimintatapaa. Välimuistit pyrkivät pitämään saatavilla viime aikoina viitattuja ja niiden lähellä olevia muistialueita. Hyvä koodaaja pystyy hyödyntämään tätä tietoa ohjelman toiminnan nopeuttamiseksi.</p><p>Muistissa olevaan tietoon viitataan käyttäen suorittimen ymmärtämiä muistinosoitusmuotoja, joista suora (indeksoitu) muistiviite on yleisimmin käytetty. Epäsuoria muistiviitteitä ei nykyään useinkaan enää käytetä, koska niiden suoritus kestää niin kauan aikaa. Sen sijaan epäsuorat muistiviitteet toteutetaan yleensä kahdella suoraa muistinosoitusta käyttävällä konekäskyllä, joista ensimmäinen hakee tiedon osoitteen muistista ja toinen sitten käyttää tätä osoitetta tiedon lukemiseen tai kirjoittamiseen. On helpompi toteuttaa nopeita suorittimia, jos kaikkien konekäskyjen (ja niiden osien) suoritus kestää yhtä kauan.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Tiedon sijainti ja siihen osoittaminen\nHuom: nämä ovat irrallisia käskyjä - ne eivät muodosta ohjelmaa.\nKaikkien käskyjen tulos talletetaan rekisteriin r2.\n\nptrX dc 453828           -- symbolin ptrX arvo on (osoitin)muuttujan ptrX\n                            osoite. (Osoitin)muuttujan ptrX arvo on\n                            muistissa olevan tiedon osoite\nTbl  ds 200              -- symbolin Tbl arvo on 200-alkioisen taulukon\n                            ensimmäisen alkion osoite\n\n    load  r2, =80        -- luku 80 on IR:n vakio-osassa\n    load  r2, Tbl(r1)    -- Tbl(r1) on suora muistinosoitusviite\n                            keskusmuistiin, osoitteeseen 280. Arvo 280 on\n                            lukujen 200 (IR:n vakio-osa) ja 80 (rek r1)\n                            summa. Tulos talletetaan r2:een.\n    add   r2, =1         -- ensimmäinen operandi on r2:ssä\n                            toinen operandi (luku 1) on IR:n vakio-osassa.\n    load  r2, Tbl(r5)    -- alkio Tbl(r5) osoitteesta 281 löytyisi\n                            luultavasti välimuistista, koska sen viereiseen\n                            alkioon osoitteessa 280 viitattiin juuri äsken.\n    load  r2, @ptrX      -- epäsuora muistiviite, ptrX arvo löytyy IR:n\n                            vakio-osasta, tiedon osoite 453828 löytyy\n                            muistista (osoitteesta ptrX), tieto löytyy\n                            muistista ptrX:n osoittamasta osoitteesta 453828</code></pre></div><h2>Tiedon sijainnin vaikutus suoritusnopeuteen</h2><p>Yleisesti ottaen kaikki tieto sijaitsee muistissa ja juuri nyt käsiteltävänä oleva tieto sijaitsee suorittimen rekistereissä. Tästä on se seuraus, että jokin tietty tieto (esim. muuttujan X arvo) voi sijaita sekä muistissa että rekisterissä. On ohjelmoijan vastuulla, että X:n arvon muuttuessa se tarvittaessa talletetaan myös muistiin. Muistissa sijaitseva tieto voi olla myös välimuistissa, mutta laitteisto huolehtii automaattisesti sen kirjoittamisesta muistiin tarvittaessa.</p><p>Korkean tason kieliä käytettäessä kääntäjä päättää, milloin jokin tieto pidetään missäkin rekisterissä. Se on itse asiassa hyvin vaikea ns. <a href=\"https://en.wikipedia.org/wiki/Register_allocation\" target=\"_blank\" rel=\"noopener noreferrer\">rekistereiden allokointiongelma</a>, koska rekistereitä on hyvin vähän ja kuitenkin kaikki laskenta tapahtuu rekistereissä olevan tiedon varassa.</p><p>Esimerkiksi, kaikkialla näkyvän laskuri Count ja sen yläraja Limit olisi hyvä pitää rekistereissä silmukan koko suoritusajan, jos niihin viitataan vähän väliä. Jos ohjelman suorituksessa on sitten pitkä tauko, jolloin Count'iin tai Limit'iin ei tule lainkaan viittauksia, niin silloin niiden arvoja ei kannata pitää rekisterissä. Ohjelmakoodissa tiedon sijainti näkyy siinä, että viitataanko suoraan rekisteriin vai haetaanko tieto ensin johonkin rekisteriin muistista.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Esimerkki: Count ja Limit rekistereissä r1 ja r2\n\n    add   r1, =1       -- kasvata muuntelumuuttujaa Count\n    comp  r1, r2       -- testaa loopin loppuminen, Count vs. Limit?\n    jless loop         -- hyppää, jos Count &lt; Limit</code></pre></div><p>Toisaalta, ei ole itsestään selvää, että muuttujien Count ja Limit arvot kannattaisi pitää rekistereissä juuri tämän silmukan suorituksen aikana. Rekistereitä on vähän ja niille voisi olla vielä tärkeämpääkin käyttöä. Niiden arvot voisi yhtä hyvin pitää muistissa. Koodista tulee (tältä osin) hitaampaa, koska suoritettavia käskyjä on enemmän ja ne viittaavat muistiin useammin.</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Esimerkki: Count ja Limit molemmat muistissa\n\n    load  r4, Count    -- lisää muuntelumuuttujaa\n    add   r4, =1\n    store r4, Count\n    load  r3, Count    -- testaa loopin loppuminen\n    comp  r3, Limit\n    jless loop</code></pre></div><p>Kolmaskin vaihtoehto on olemassa. Silmukan muuntelumuuttujan arvon voi pitää rekisterissä silmukan suoritusajan ja sitten lopuksi tallettaa muistiin. Esimerkiksi C-kielessä muuntelumuuttujat ovat tavallisia muuttujia ja niiden loppuarvon täytyy olla käytettävissä myös silmukan jälkeen. Joissakin toisissa kielissä muuntelumuuttujan arvoa ei ole määritelty silmukan päättyessä tai muuntelumuuttujaa ei ole edes määritelty silmukan ulkopuolella. Korkean tason ohjelmointikieliä on hyvin erilaisia ja niillä on merkittäviä mielenkiintoisia eroavaisuuksia!</p><div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Esimerkki: muuntelumuuttuja rekisterissä ja muistissa\n\n      load  r1, =0    -- alusta muuntelumuuttuja i (r1:ssä)\n\nloop  comp  r1, =50   -- testaa loopin loppuminen\n      jnles done\n\n      ...             -- for-silmukan runko (itse asia) tässä\n      ...\n\n      add   r1, =1    -- i:n lisäys ja paluu silmukkaan\n      jump  loop\n\ndone  store  r1, i    -- talleta i:n loppuarvo (koska ohjelmointikielen\n                         semantiikka sitä vaatii)</code></pre></div><p>On siis tapauksia, joissa ohjelmassa nimetty tieto ei sijaitse missään tällä hetkellä. Edellä mainitun silmukan muuntelumuuttujan lisäksi tällaisia tietoja ovat aliohjelmien paikalliset muuttujat ja muut tietorakenteet, jotka varataan muistista vasta aliohjelmaa kutsuttaessa ja vapautetaan muistista aliohjelmasta poistuttaessa.</p><p>Käskyrekisterin (IR) kautta jotain vakioarvoa käytettäessä kääntäjällä (koodin kirjoittajalla) on kaksi mahdollisuutta. Käskyrekisteriin voidaan laittaa itse vakio (esim. arvo 1000), joka sitten replikoidaan jokaiseen tuota tietoa käyttävään konekäskyyn. Toinen vaihtoehto on tallettaa vakio muistiin ja laittaa jokaiseen siihen viittaaviin konekäskyyn vakion osoite muistissa. Molemmilla lähestymistavoilla on etunsa ja haittansa. Konekäskyssä oleva vakiolla voi olla koko- tai tyyppirajoitus, mutta sen käyttö on nopeata. Muistissa olevaan vakioon on hitaampi viitata, mutta sitä voi tarvittaessa kuitenkin muokata.</p><p>Välimuistin käyttö on tuuripeliä, mutta siihen voi vaikuttaa. On aina tehokkaampaa käydä läpi mitä tahansa suurempaa tietomassaa samassa järjestyksessä kuin se on talletettu muistiin. Ohjelmakoodin tasolla tämä tarkoittaa hyppyjen ja haarautumisten välttämistä, mikä ei käytännössä ole lainkaan helppoa. Koodissa viitatun datan osalta se tarkoittaa, että esimerkiksi 2-ulotteisia taulukoita voi olla parempi käydä läpi riveittäin kuin sarakettain. Usein ohjelmalogiikka valitettavasti vaatii tiedon läpikäyntiä välimuistin kannalta \"tehottomassa\" järjestyksessä. Aina ei voi voittaa!</p><!-- Quiz 2.4.1-10 Väitteet tiedon sijainnin vaikutuksesta suoritusnopeuteen --><div><quiz id=\"8f488186-0578-5cc4-bf46-a77fe54af7af\"></quiz></div>\n<div><quiz id=\"dc21b029-65d6-5322-8e05-df303023edae\"></quiz></div>\n<div><quiz id=\"f6956e5d-0428-53b2-bdaf-2c812a81b6ce\"></quiz></div>\n<div><quiz id=\"6b4bcf9a-245c-57e4-ab80-81b58fe170f7\"></quiz></div>\n<div><quiz id=\"7c53d5ad-94c6-5cbc-af8d-9833f96a42ac\"></quiz></div>\n<div><quiz id=\"cdd04b1e-f14f-5232-a8aa-e58237fb4e1e\"></quiz></div>\n<div><quiz id=\"1cd5d5c2-f658-578d-a037-4842b560ff7e\"></quiz></div>\n<div><quiz id=\"5e7457a6-4dcb-5ec8-a9c5-c8effb937c9d\"></quiz></div>\n<div><quiz id=\"1176fc2f-5b57-5d31-9d0b-5885aebd88a0\"></quiz></div>\n<div><quiz id=\"be782d06-a745-56f7-aac2-351904fd5ba1\"></quiz></div><text-box variant=\"example\" name=\"Historiaa:  ESKO\"><p>ESKO eli Elektroninen SarjaKOmputaattori (1960) oli ensimmäinen Suomessa rakennettu tietokone. Se oli vanhentunut jo valmistuessaan ja suoritti noin 20 yhteenlaskua sekunnissa. Ohjelmakoodi luettiin reikänauhoilta. Aliohjelmaa kutsuttiin siirtämällä kontrolli sitä vastaavaan reikänauhan lukijaan, jossa aliohjelman koodi oli reikänauhalla ikuisessa silmukassa. Muistina oli 1840 sanan rumpumuisti. ESKOn varsinainen arvo oli tuoda tietotekniikan osaamista Suomeen.</p><!-- kuva: ch-2-4-esko    --><p><img src=\"/544abd152e535061bc4370765d71aa03/ch-2-4-esko.svg\" alt=\"Kaksi valokuvaa. Vasemmalla ESKO kokonaisuudessaan ja sen edessä muistina toimiva rumpumuisti ja reikänauhan lukijat. Oikealla on lähikuva reikänauhan lukijoista.\"></p><div>\n<illustrations motive=\"ch-2-4-esko\"></illustrations>\n</div></text-box><h2>Yhteenveto</h2><p>Toinen luku käsitteli suorittimen ja muistin toimintaa. Aluksi katsoimme vähän tarkemmin suorittimen rakennetta ja erityisesti sen toimintaa käskyjen nouto- ja suoritussyklin toteuttajana. Sen jälkeen tarkastelimme konekäskyjen eri tyyppejä ja rakennetta. Lopuksi katsoimme, kuinka tiedon sijainti suoritusaikana voi vaihdella ja kuinka se vaikuttaa ohjelmien suoritusnopeuteen.</p><p>Vastaa alla olevaan kyselyyn, kun olet valmis tämän luvun tehtävien kanssa.</p><div><quiz id=\"cf78e5e2-6922-503c-a07b-783cec690d86\"></quiz></div></div>","frontmatter":{"path":"/luku-2/4-tiedon-sijainti","title":"Tiedon sijainti suoritusaikana"}},"allPages":{"edges":[{"node":{"id":"f84c69b8-0195-598e-b051-638a517adb15","frontmatter":{"path":"/arvostelu-ja-kokeet","title":"Arvostelu ja kokeet"}}},{"node":{"id":"97559a5f-7228-505c-a45a-e0873044f86b","frontmatter":{"path":"/credits","title":"Tekijänoikeudet ja lisenssit"}}},{"node":{"id":"b5e3212a-e9e7-5514-87e6-07e3f18fee95","frontmatter":{"path":"/opettajille","title":"Opettajille ja opinto-ohjaajille"}}},{"node":{"id":"a0c4823b-46b6-5707-beb2-8a229b5a2beb","frontmatter":{"path":"/osaamistavoitteet","title":"Osaamistavoitteet"}}},{"node":{"id":"dbb6d14b-2dea-5f9a-85fc-30eb59a77a70","frontmatter":{"path":"/","title":""}}},{"node":{"id":"a0c06bb0-616a-594f-b31a-cf57faa3a1ed","frontmatter":{"path":"/tukivaylat","title":"Tukiväylät"}}},{"node":{"id":"ea6e5cfa-14c1-53b5-99da-25b985ab3a7b","frontmatter":{"path":"/usein-kysytyt-kysymykset","title":"Palaute ja usein kysytyt kysymykset"}}},{"node":{"id":"d9390807-bada-58ad-a2b0-59515c977a08","frontmatter":{"path":"/luku-1/2-ohjelma","title":"Ohjelma"}}},{"node":{"id":"7c078337-dddc-5acf-ab5e-7ade2e1444c5","frontmatter":{"path":"/luku-1/3-laitteiston-nopeuserot","title":"Laitteiston nopeuserot"}}},{"node":{"id":"cafd05e1-5355-5bf8-a41c-b955593fd3fd","frontmatter":{"path":"/luku-1/1-mika-on-tietokone","title":"Tietokone"}}},{"node":{"id":"03eacc49-4552-5b0b-bd14-e18ee30fea39","frontmatter":{"path":"/luku-1","title":"Luku 1: Tietokonejärjestelmä ja ohjelma?"}}},{"node":{"id":"25190d7c-3ec2-5d92-bc9b-a9eaea77075b","frontmatter":{"path":"/luku-2/2-suoritussykli","title":"Käskyjen nouto- ja suoritussykli"}}},{"node":{"id":"c9b57a30-4ec9-53c6-ba7e-6e2d020edf88","frontmatter":{"path":"/luku-2/4-tiedon-sijainti","title":"Tiedon sijainti suoritusaikana"}}},{"node":{"id":"8fd68708-1f3b-5ded-857f-4ff583ebe0a2","frontmatter":{"path":"/luku-2/1-suorittimen-rakenne","title":"Suorittimen rakenne"}}},{"node":{"id":"a23135b2-b131-59cd-b1c6-cfefd4c12714","frontmatter":{"path":"/luku-2/3-konekaskyt","title":"Konekäskyt"}}},{"node":{"id":"bb32b4c9-f268-5ee0-ab30-2c8015858045","frontmatter":{"path":"/luku-2","title":"Luku 2: Suoritin ja muisti"}}},{"node":{"id":"0363ae7c-d894-551b-b701-4d6154421c91","frontmatter":{"path":"/luku-3/1-tiedon-kategoriat","title":"Tiedon kategoriat, binääri- ja heksadesimaalijärjestelmät, monitavuisen tiedon tallennus"}}},{"node":{"id":"90801e3d-d0e8-5485-86f5-8e0192f5535e","frontmatter":{"path":"/luku-3/3-taulukot-tietueet","title":"Taulukot, tietueet ja muu rakenteinen tieto"}}},{"node":{"id":"b4f1ad3e-ddda-5fe0-81b4-1d3cd70451ca","frontmatter":{"path":"/luku-3/2-kokonaisluvut-ja-liukuluvut","title":"Kokonaislukujen ja liukulukujen esitysmuodot"}}},{"node":{"id":"f778c926-0e93-5b7a-9b50-5fd503f42528","frontmatter":{"path":"/luku-3","title":"Luku 3: Tiedon esitysmuodot"}}},{"node":{"id":"6dddcd21-639d-504f-88cc-db830c98f75c","frontmatter":{"path":"/luku-3/4-merkit-etc","title":"Merkit, kuvat ja tunteenpalo"}}},{"node":{"id":"3d13f5ae-50f5-5454-a662-9bf3e2bde459","frontmatter":{"path":"/luku-4/1-kayttojarjestelman-tehtavat","title":"Käyttöjärjestelmän tehtävät"}}},{"node":{"id":"3187dc8f-8296-53a6-b73a-9880d556ae9b","frontmatter":{"path":"/luku-4/2-prosessi","title":"Prosessi"}}},{"node":{"id":"b74906bf-020f-526d-a4a0-d079accbb347","frontmatter":{"path":"/luku-4/3-kayttojarjestelman-toteutus","title":"Käyttöjärjestelmän toteutus"}}},{"node":{"id":"7c3125f9-4d7c-52fe-83e1-bf564067c597","frontmatter":{"path":"/luku-4/4-laskentakyvyn-rajat","title":"Tietokoneen laskentakyvyn rajat"}}},{"node":{"id":"20ffd10f-ce80-5f7e-9c31-cf0bc2bb2edd","frontmatter":{"path":"/luku-4","title":"Luku 4: Käyttöjärjestelmä ja laskentakyvyn rajat"}}}]}},"pageContext":{}},
    "staticQueryHashes": ["2283872788","994120085"]}